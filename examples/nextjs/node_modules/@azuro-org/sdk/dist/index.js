import {c as cookieKeys,a as configRef,l as localStorageKeys,D as DEFAULT_DEADLINE}from'./config.js';import {jsx,jsxs}from'react/jsx-runtime';import {createContext,useContext,useState,useRef,useMemo,useCallback,useEffect,useReducer}from'react';import {useAccount,useConfig,useWatchContractEvent,usePublicClient,useWriteContract,useWaitForTransactionReceipt,useWalletClient,useBalance,useReadContract,useSendTransaction}from'wagmi';import {chainsData,liveHostAddress,calcPrematchOdds,calcLiveOdds,PrematchConditionsBatchDocument,getFreeBets,ODDS_DECIMALS,ConditionStatus,MIN_LIVE_BET_AMOUNT,MainGameInfoFragmentDoc,PrematchConditionFragmentDoc,liveSupportedChains,Bet_OrderBy,OrderDirection,GraphBetStatus,PrematchBetsDocument,BetResult,SelectionResult,PrematchGraphGameStatus,LiveBetsDocument,GamesDocument,PrematchConditionsDocument,LiveConditionsDocument,MARGIN_DECIMALS,GameDocument,GameStatus,groupConditionsByMarket,Game_OrderBy,SportsDocument,SportsNavigationDocument,NavigationDocument,getLiveBetFee,BettorsDocument,GameBetsDocument,LiveBetFragmentDoc,PrematchBetFragmentDoc,BettorFragmentDoc,LiveConditionFragmentDoc,LiveConditionDocument,PrematchConditionDocument,liveCoreAbi,freeBetAbi,calcMindOdds,getPrematchBetDataBytes,getGameStatus,getWaveLevels,getWaveStats,getWavePeriods,getWaveLeaderBoard,activateWave,getDeBridgeSupportedChains,getDeBridgeSupportedTokens,createDeBridgeBet,getDeBridgeOrder,DeBridgeExternalCallStatus,DeBridgeOrderStatus}from'@azuro-org/toolkit';import {HttpLink,ApolloClient,InMemoryCache,useQuery as useQuery$1}from'@apollo/client';import {decodeEventLog,formatUnits,parseUnits,erc20Abi,maxUint256,encodeFunctionData,zeroAddress}from'viem';import {getMarketName,getSelectionName}from'@azuro-org/dictionaries';import {useQuery,useQueryClient,useMutation}from'@tanstack/react-query';import {readContract,getTransactionReceipt}from'@wagmi/core';var SportHub;
(function (SportHub) {
    SportHub["Sports"] = "sports";
    SportHub["Esports"] = "esports";
    SportHub["Unique"] = "unique";
})(SportHub || (SportHub = {}));
var BetType;
(function (BetType) {
    BetType["Unredeemed"] = "unredeemed";
    BetType["Accepted"] = "accepted";
    BetType["Settled"] = "settled";
})(BetType || (BetType = {}));const ChainContext = createContext(null);
const useChain = () => {
    return useContext(ChainContext);
};
const ChainProvider = (props) => {
    const { children, initialChainId } = props;
    const [appChainId, setAppChainId] = useState(initialChainId);
    const { chain: walletChain } = useAccount();
    const walletChainId = walletChain?.id || null;
    const isRightNetwork = walletChainId === appChainId;
    const { chain, contracts, betToken, graphql, socket, api, environment } = chainsData[appChainId];
    const handleChangeChain = (chainId) => {
        document.cookie = `${cookieKeys.appChainId}=${chainId};path=/;`;
        setAppChainId(chainId);
    };
    const context = {
        appChain: chain,
        walletChain,
        contracts,
        betToken,
        graphql,
        socket,
        api,
        environment,
        isRightNetwork,
        setAppChainId: handleChangeChain,
    };
    return (jsx(ChainContext.Provider, { value: context, children: children }));
};const getPrematchLink = (chainId) => {
    return new HttpLink({
        uri: ({ operationName }) => `${chainsData[chainId].graphql.prematch}?op=${operationName}`,
    });
};
const getLiveLink = (chainId) => {
    return new HttpLink({
        uri: ({ operationName }) => `${chainsData[chainId].graphql.live}?op=${operationName}`,
    });
};
const typePolicies = {
    Query: {
        fields: {
            bets: {
                merge(existing, incoming, { args }) {
                    // in case of fetching first paginated portion, we should drop cache to avoid data mismatch/shifting
                    if (!args?.skip || !existing?.length) {
                        return incoming;
                    }
                    return [...(existing || []), ...incoming];
                },
            },
            liveBets: {
                merge(existing, incoming, { args }) {
                    // in case of fetching first paginated portion, we should drop cache to avoid data mismatch/shifting
                    if (!args?.skip || !existing?.length) {
                        return incoming;
                    }
                    return [...(existing || []), ...incoming];
                },
            },
        },
    },
};
const getPrematchApolloClient = (chainId) => {
    const link = getPrematchLink(chainId);
    return new ApolloClient({
        link,
        ssrMode: typeof window === 'undefined',
        cache: new InMemoryCache({ typePolicies }),
        connectToDevTools: true,
        assumeImmutableResults: true,
    });
};
const getLiveApolloClient = (chainId) => {
    const link = getLiveLink(chainId);
    return new ApolloClient({
        link,
        ssrMode: typeof window === 'undefined',
        cache: new InMemoryCache(),
        connectToDevTools: true,
        assumeImmutableResults: true,
    });
};
const apolloClients = {
    prematchClient: null,
    liveClient: null,
};
const getApolloClients = (chainId) => {
    if (typeof window === 'undefined') {
        return {
            prematchClient: getPrematchApolloClient(chainId),
            liveClient: getLiveApolloClient(chainId),
        };
    }
    if (!apolloClients.prematchClient) {
        apolloClients.prematchClient = getPrematchApolloClient(chainId);
        apolloClients.liveClient = getLiveApolloClient(chainId);
    }
    return apolloClients;
};
const Context = createContext(null);
const useApolloClients = () => {
    return useContext(Context);
};
const ApolloProvider = (props) => {
    const { children } = props;
    const { appChain } = useChain();
    const prevAppChainIdRef = useRef(appChain.id);
    const apolloClientsRef = useRef(getApolloClients(appChain.id));
    // set new link before render for send requests with new one
    useMemo(() => {
        if (appChain.id !== prevAppChainIdRef.current) {
            const { prematchClient, liveClient } = apolloClientsRef.current;
            const prematchLink = getPrematchLink(appChain.id);
            prematchClient.setLink(prematchLink);
            prematchClient.resetStore();
            if (chainsData[prevAppChainIdRef.current].graphql.live !== chainsData[appChain.id].graphql.live) {
                const liveLink = getLiveLink(appChain.id);
                liveClient.setLink(liveLink);
                liveClient.resetStore();
            }
            prevAppChainIdRef.current = appChain.id;
        }
    }, [appChain.id]);
    return (jsx(Context.Provider, { value: apolloClientsRef.current, children: children }));
};let ref = {
    lastUpdateTime: undefined,
};
const getGameStartsAtValue = () => {
    let startsAt;
    const dateNow = Math.floor(Date.now() / 1000);
    // if first render or current time is greater the previous saved more than cache time
    if (!ref.lastUpdateTime
        || dateNow - ref.lastUpdateTime > configRef.gamesCacheTime) {
        startsAt = dateNow;
        ref.lastUpdateTime = dateNow;
    }
    else {
        startsAt = ref.lastUpdateTime;
    }
    return startsAt;
};const getEventArgsFromTxReceipt = ({ receipt, eventName, abi, params }) => {
    const { logs } = receipt;
    let result;
    for (let index = 0; index < logs.length; index++) {
        try {
            const log = logs[index];
            result = decodeEventLog({
                abi,
                topics: log.topics,
                eventName,
                data: log.data,
            });
            if (result.eventName.toLowerCase() !== eventName.toLowerCase()) {
                result = undefined;
                continue;
            }
            if (params && result?.args) {
                const isMatchByParams = Object.keys(params).every(paramKey => {
                    return result.args[paramKey] === params[paramKey];
                });
                if (!isMatchByParams) {
                    result = undefined;
                }
            }
            if (result) {
                break;
            }
        }
        catch { }
    }
    if (result?.args) {
        return result?.args;
    }
};const formatToFixed = (value, digitsCount) => {
    value = String(value);
    if (!/\./.test(value)) {
        return +value;
    }
    const [int, digits] = value.split('.');
    return +`${int}.${digits.substr(0, digitsCount)}`;
};function debounce(func, wait, withMaxRequests) {
    let timeout;
    let requests = 0;
    return function (...args) {
        const context = this;
        const later = function () {
            timeout = undefined;
            requests = 0;
            func.apply(context, args);
        };
        if (withMaxRequests) {
            requests++;
        }
        if (timeout !== undefined) {
            clearTimeout(timeout);
        }
        if (requests > 10) {
            requests = 0;
            func.apply(context, args);
        }
        else {
            timeout = setTimeout(later, wait);
        }
    };
}const createBatch = (fn, isSet = true) => {
    let idsWaitList = isSet ? new Set() : [];
    let resolversWaitList = [];
    const request = debounce(async (fn, ...rest) => {
        const ids = [...idsWaitList];
        const resolvers = resolversWaitList;
        if (idsWaitList instanceof Set) {
            idsWaitList.clear();
        }
        else {
            idsWaitList = [];
        }
        resolversWaitList = [];
        try {
            const data = await fn(ids, ...rest);
            resolvers.forEach((resolve) => {
                resolve(data);
            });
        }
        catch (err) {
            resolvers.forEach((resolve) => {
                resolve(undefined);
            });
        }
    }, 50, true);
    const batch = (ids, ...rest) => {
        request(fn, ...rest);
        ids.forEach(id => {
            if (idsWaitList instanceof Set) {
                idsWaitList.add(id);
            }
            else {
                idsWaitList.push(id);
            }
        });
        return new Promise((resolve) => {
            resolversWaitList.push(resolve);
        });
    };
    return batch;
};const timers$1 = new Map();
const subscribers$1 = new Map();
const subscribe$1 = (conditionId, cb) => {
    const key = conditionId;
    const handlers = subscribers$1.get(key) || [];
    handlers.push({ cb });
    subscribers$1.set(key, handlers);
    return function unsubscribe() {
        const handlers = subscribers$1.get(key) || [];
        const newHandlers = handlers.filter((handler) => handler.cb !== cb);
        if (newHandlers.length) {
            subscribers$1.set(key, newHandlers);
        }
        else {
            subscribers$1.delete(key);
        }
    };
};
const trigger$1 = (conditionId, status) => {
    const handlers = subscribers$1.get(conditionId) || [];
    handlers.forEach(({ cb }) => {
        cb(status);
    });
};
const dispatch$1 = (conditionId, status) => {
    let timer = timers$1.get(conditionId);
    if (timer !== undefined) {
        clearTimeout(timer);
    }
    timer = setTimeout(() => {
        timers$1.delete(conditionId);
        trigger$1(conditionId, status);
    }, 200);
    timers$1.set(conditionId, timer);
};
const conditionStatusWatcher = {
    subscribe: subscribe$1,
    dispatch: dispatch$1,
};const timers = new Map();
const subscribers = new Map();
const subscribe = (conditionId, outcomeId, cb) => {
    const key = conditionId;
    const handlers = subscribers.get(key) || [];
    handlers.push({ outcomeId, cb });
    subscribers.set(key, handlers);
    return function unsubscribe() {
        const handlers = subscribers.get(key) || [];
        const newHandlers = handlers.filter((handler) => handler.cb !== cb);
        if (newHandlers.length) {
            subscribers.set(key, newHandlers);
        }
        else {
            subscribers.delete(key);
        }
    };
};
const trigger = async (conditionId, oddsData) => {
    const handlers = subscribers.get(conditionId) || [];
    handlers.forEach(({ cb }) => {
        cb(oddsData);
    });
};
const dispatch = (conditionId, oddsData) => {
    let timer = timers.get(conditionId);
    if (timer !== undefined) {
        clearTimeout(timer);
    }
    timer = setTimeout(() => {
        timers.delete(conditionId);
        trigger(conditionId, oddsData);
    }, 200);
    timers.set(conditionId, timer);
};
const oddsWatcher = {
    subscribe,
    dispatch,
};var SocketCloseReason;
(function (SocketCloseReason) {
    SocketCloseReason[SocketCloseReason["ChainChanged"] = 3000] = "ChainChanged";
})(SocketCloseReason || (SocketCloseReason = {}));
const SocketContext = createContext(null);
const useSocket = () => {
    return useContext(SocketContext);
};
const SocketProvider = ({ children }) => {
    const { appChain } = useChain();
    const [isSocketReady, setSocketReady] = useState(false);
    const prevChainId = useRef(appChain.id);
    const socket = useRef();
    const subscribers = useRef({});
    const subscribe = useCallback((conditionIds) => {
        if (!isSocketReady) {
            throw Error('socket isn\'t ready');
        }
        conditionIds.forEach((conditionId) => {
            if (typeof subscribers.current[conditionId] === 'undefined') {
                subscribers.current[conditionId] = 0;
            }
            subscribers.current[conditionId] += 1;
        });
        socket.current.send(JSON.stringify({
            action: 'subscribe',
            conditionIds,
        }));
    }, [isSocketReady]);
    const unsubscribe = useCallback((conditionIds) => {
        if (!isSocketReady) {
            throw Error('socket isn\'t ready');
        }
        // we mustn't unsubscribe for condition if it has more that 1 subscriber
        const newUnsubscribers = [];
        conditionIds.forEach((conditionId) => {
            if (subscribers.current[conditionId]) {
                if (subscribers.current[conditionId] > 1) {
                    subscribers.current[conditionId] -= 1;
                }
                else {
                    subscribers.current[conditionId] = 0;
                    newUnsubscribers.push(conditionId);
                }
            }
        });
        if (!newUnsubscribers.length) {
            return;
        }
        socket.current.send(JSON.stringify({
            action: 'unsubscribe',
            conditionIds: newUnsubscribers,
        }));
    }, [isSocketReady]);
    const subscribeToUpdates = useCallback(createBatch(subscribe), [subscribe]);
    const unsubscribeToUpdates = useCallback(createBatch(unsubscribe), [unsubscribe]);
    const connect = () => {
        socket.current = new WebSocket(chainsData[appChain.id].socket);
        socket.current.onopen = () => {
            setSocketReady(true);
        };
        socket.current.onclose = (event) => {
            if (event.code === SocketCloseReason.ChainChanged) {
                return;
            }
            socket.current = undefined;
            setSocketReady(false);
            connect();
        };
        socket.current.onmessage = (message) => {
            JSON.parse(message.data.toString()).forEach((data) => {
                const { id: conditionId, reinforcement, margin, winningOutcomesCount } = data;
                if (data.outcomes) {
                    const eventData = {
                        conditionId: conditionId,
                        reinforcement: +reinforcement,
                        margin: +margin,
                        winningOutcomesCount: +winningOutcomesCount,
                        outcomes: {},
                    };
                    eventData.outcomes = data.outcomes.reduce((acc, { id, odds, clearOdds, maxStake }) => {
                        acc[id] = {
                            odds,
                            clearOdds,
                            maxBet: maxStake,
                        };
                        return acc;
                    }, {});
                    oddsWatcher.dispatch(conditionId, eventData);
                }
                if (data.state) {
                    conditionStatusWatcher.dispatch(conditionId, data.state);
                }
            });
        };
        socket.current.onerror = () => {
            socket.current = undefined;
            setSocketReady(false);
            setTimeout(connect, 1000);
        };
    };
    useEffect(() => {
        if (isSocketReady
            && socket.current
            && prevChainId.current !== appChain.id
            && chainsData[prevChainId.current].socket !== chainsData[appChain.id].socket) {
            unsubscribe(Object.keys(subscribers.current));
            socket.current.close(SocketCloseReason.ChainChanged);
            socket.current = undefined;
            setSocketReady(false);
        }
        prevChainId.current = appChain.id;
    }, [appChain, isSocketReady]);
    useEffect(() => {
        if (typeof socket.current !== 'undefined') {
            return;
        }
        connect();
    }, [appChain]);
    const value = {
        isSocketReady,
        subscribeToUpdates,
        unsubscribeToUpdates,
    };
    return (jsx(SocketContext.Provider, { value: value, children: children }));
};const useIsMounted = () => {
    const isMountedRef = useRef(false);
    useEffect(() => {
        isMountedRef.current = true;
        return () => {
            isMountedRef.current = false;
        };
    }, []);
    return () => isMountedRef.current;
};const useOdds = ({ selections, betAmount, batchBetAmounts }) => {
    const { isSocketReady, subscribeToUpdates, unsubscribeToUpdates } = useSocket();
    const { appChain } = useChain();
    const config = useConfig();
    const isMounted = useIsMounted();
    const { liveItems, prematchItems } = useMemo(() => {
        return selections.reduce((acc, item) => {
            if (item.coreAddress.toLocaleLowerCase() === liveHostAddress.toLocaleLowerCase()) {
                acc.liveItems.push(item);
            }
            else {
                acc.prematchItems.push(item);
            }
            return acc;
        }, {
            liveItems: [],
            prematchItems: [],
        });
    }, [selections]);
    const [odds, setOdds] = useState({});
    const [totalOdds, setTotalOdds] = useState(0);
    const [isPrematchOddsFetching, setPrematchOddsFetching] = useState(Boolean(prematchItems.length));
    const oddsDataRef = useRef({});
    const betAmountRef = useRef(betAmount);
    const batchBetAmountsRef = useRef(batchBetAmounts);
    betAmountRef.current = betAmount;
    batchBetAmountsRef.current = batchBetAmounts;
    const liveKey = liveItems.map(({ conditionId }) => conditionId).join('-');
    const isLiveOddsFetching = useMemo(() => {
        return !liveItems.every(({ conditionId, outcomeId }) => Boolean(odds[`${conditionId}-${outcomeId}`]));
    }, [liveKey, odds]);
    const maxBet = useMemo(() => {
        if (!liveItems.length || liveItems.length > 1) {
            return undefined;
        }
        const { conditionId, outcomeId } = liveItems[0];
        return oddsDataRef.current?.[conditionId]?.outcomes?.[outcomeId]?.maxBet;
    }, [liveKey, odds]); // we need odds in deps because we update oddsDataRef with odds
    const fetchPrematchOdds = async () => {
        if (!prematchItems.length) {
            return;
        }
        try {
            const prematchOdds = await calcPrematchOdds({
                config,
                betAmount: betAmountRef.current,
                batchBetAmounts: batchBetAmountsRef.current,
                selections: prematchItems,
                chainId: appChain.id,
            });
            if (isMounted()) {
                setOdds(odds => {
                    const newOdds = { ...odds, ...prematchOdds };
                    const newTotalOdds = formatToFixed(Object.keys(newOdds).reduce((acc, key) => acc * +newOdds[key], 1), 3);
                    setTotalOdds(newTotalOdds);
                    return newOdds;
                });
                setPrematchOddsFetching(false);
            }
        }
        catch (err) {
            if (isMounted()) {
                setPrematchOddsFetching(false);
            }
        }
    };
    const fetchLiveOdds = (items, newOddsData) => {
        if (!items.length) {
            return;
        }
        if (newOddsData) {
            oddsDataRef.current[newOddsData.conditionId] = newOddsData;
        }
        const liveOdds = items.reduce((acc, item) => {
            const { conditionId, outcomeId } = item;
            const oddsData = oddsDataRef.current[conditionId];
            if (!oddsData) {
                return acc;
            }
            acc[`${conditionId}-${outcomeId}`] = calcLiveOdds({ selection: item, betAmount: betAmountRef.current, oddsData });
            return acc;
        }, {});
        setOdds(odds => {
            const newOdds = { ...odds, ...liveOdds };
            const newTotalOdds = formatToFixed(Object.keys(newOdds).reduce((acc, key) => acc * +newOdds[key], 1), 3);
            setTotalOdds(newTotalOdds);
            return newOdds;
        });
    };
    const fetchOdds = useCallback(debounce(() => {
        setOdds({});
        setTotalOdds(1);
        setPrematchOddsFetching(Boolean(prematchItems.length));
        fetchPrematchOdds();
        fetchLiveOdds(liveItems);
    }, 100), [selections]);
    useEffect(() => {
        if (!isSocketReady || !liveItems.length) {
            return;
        }
        const ids = liveKey.split('-');
        subscribeToUpdates(ids);
        return () => {
            unsubscribeToUpdates(ids);
        };
    }, [liveKey, isSocketReady]);
    useEffect(() => {
        fetchOdds();
    }, [fetchOdds, betAmount, batchBetAmounts]);
    useEffect(() => {
        if (!selections?.length) {
            return;
        }
        const unsubscribeList = selections.map(({ conditionId, outcomeId }) => {
            return oddsWatcher.subscribe(`${conditionId}`, `${outcomeId}`, (oddsData) => {
                if (oddsData) {
                    const item = liveItems.find(item => item.conditionId === oddsData.conditionId);
                    fetchLiveOdds([item], oddsData);
                }
                else {
                    setPrematchOddsFetching(true);
                    fetchPrematchOdds();
                }
            });
        });
        return () => {
            unsubscribeList.forEach((unsubscribe) => {
                unsubscribe();
            });
        };
    }, [selections]);
    return {
        odds,
        totalOdds,
        maxBet,
        loading: isPrematchOddsFetching || isLiveOddsFetching,
    };
};const getConditions = (conditionEntityIds, client) => {
    return client.query({
        query: PrematchConditionsBatchDocument,
        variables: {
            conditionFilter: {
                id_in: conditionEntityIds,
            },
        },
        fetchPolicy: 'network-only',
    });
};
const batchFetchConditions = createBatch(getConditions);const useStatuses = ({ selections }) => {
    const { isSocketReady, subscribeToUpdates, unsubscribeToUpdates } = useSocket();
    const { prematchClient } = useApolloClients();
    const [statuses, setStatuses] = useState({});
    const { liveItems, prematchItems } = useMemo(() => {
        return selections.reduce((acc, item) => {
            if (item.coreAddress.toLocaleLowerCase() === liveHostAddress.toLocaleLowerCase()) {
                acc.liveItems.push(item);
            }
            else {
                acc.prematchItems.push(item);
            }
            return acc;
        }, {
            liveItems: [],
            prematchItems: [],
        });
    }, [selections]);
    const [isPrematchStatusesFetching, setPrematchStatusesFetching] = useState(Boolean(prematchItems.length));
    const liveKey = liveItems.map(({ conditionId }) => conditionId).join('-');
    const prematchKey = prematchItems.map(({ conditionId }) => conditionId).join('-');
    const selectionsKey = selections.map(({ conditionId }) => conditionId).join('-');
    const isLiveStatusesFetching = useMemo(() => {
        return !liveItems.every(({ conditionId }) => Boolean(statuses[conditionId]));
    }, [liveKey, statuses]);
    useEffect(() => {
        if (!isSocketReady || !liveItems.length) {
            return;
        }
        const ids = liveKey.split('-');
        subscribeToUpdates(ids);
        return () => {
            unsubscribeToUpdates(ids);
        };
    }, [liveKey, isSocketReady]);
    useEffect(() => {
        if (!selections.length) {
            return;
        }
        setStatuses({});
        const unsubscribeList = selections.map(({ conditionId }) => {
            return conditionStatusWatcher.subscribe(conditionId, (newStatus) => {
                setStatuses(statuses => ({
                    ...statuses,
                    [conditionId]: newStatus,
                }));
            });
        });
        return () => {
            unsubscribeList.forEach((unsubscribe) => {
                unsubscribe();
            });
        };
    }, [selectionsKey]);
    useEffect(() => {
        if (!prematchItems.length) {
            return;
        }
        setPrematchStatusesFetching(true);
        (async () => {
            const { data: { conditions } } = await batchFetchConditions(prematchItems.map(({ conditionId, coreAddress }) => `${coreAddress.toLowerCase()}_${conditionId}`), prematchClient);
            const prematchStatuses = conditions.reduce((acc, { conditionId, status }) => {
                acc[conditionId] = status;
                return acc;
            }, {});
            setPrematchStatusesFetching(false);
            setStatuses(prematchStatuses);
        })();
    }, [prematchKey]);
    return {
        statuses,
        loading: isPrematchStatusesFetching || isLiveStatusesFetching,
    };
};const useFreeBets = ({ account, affiliate, enabled }) => {
    const { appChain, api } = useChain();
    const queryFn = async () => {
        const freebets = await getFreeBets({
            chainId: appChain.id,
            account,
            affiliate,
        });
        if (!freebets) {
            return freebets;
        }
        return freebets.map(freebet => ({
            id: +freebet.id,
            contractAddress: freebet.contract.freebetContractAddress,
            signature: freebet.signature,
            expiresAt: freebet.expiresAt * 1000,
            amount: formatUnits(BigInt(freebet.amount), freebet.contract.decimals),
            rawAmount: BigInt(freebet.amount),
            minOdds: formatUnits(BigInt(freebet.minOdds), ODDS_DECIMALS),
            rawMinOdds: BigInt(freebet.minOdds),
            campaign: freebet.campaign,
            chainId: +freebet.contract.chainId,
        }));
    };
    const { data, ...rest } = useQuery({
        queryKey: ['freebets', api, account?.toLowerCase(), affiliate?.toLowerCase()],
        queryFn,
        refetchOnWindowFocus: false,
        enabled,
    });
    const appChainFreeBets = useMemo(() => {
        if (!data) {
            return data;
        }
        return data.filter(({ chainId }) => +chainId === appChain.id);
    }, [data, appChain.id]);
    return {
        data: appChainFreeBets,
        ...rest,
    };
};const formatBetValue = (value) => {
    let newValue = value;
    const [int, digits] = newValue.split('.');
    if (digits) {
        newValue = `${int}.${digits.substring(0, 2)}`;
    }
    return newValue;
};const useForceUpdate = () => {
    const [increment, setState] = useState(0);
    const forceUpdate = useCallback(() => {
        setState((v) => ++v);
    }, []);
    return { increment, forceUpdate };
};var BetslipDisableReason;
(function (BetslipDisableReason) {
    BetslipDisableReason["ConditionStatus"] = "ConditionStatus";
    BetslipDisableReason["BetAmountGreaterThanMaxBet"] = "BetAmountGreaterThanMaxBet";
    BetslipDisableReason["BetAmountLowerThanMinBet"] = "BetAmountLowerThanMinBet";
    BetslipDisableReason["BatchWithLive"] = "BatchWithLive";
    BetslipDisableReason["ComboWithLive"] = "ComboWithLive";
    BetslipDisableReason["ComboWithForbiddenItem"] = "ComboWithForbiddenItem";
    BetslipDisableReason["ComboWithSameGame"] = "ComboWithSameGame";
    BetslipDisableReason["PrematchConditionInStartedGame"] = "PrematchConditionInStartedGame";
    BetslipDisableReason["FreeBetWithLive"] = "FreeBetWithLive";
    BetslipDisableReason["FreeBetWithCombo"] = "FreeBetWithCombo";
    BetslipDisableReason["FreeBetWithBatch"] = "FreeBetWithBatch";
    BetslipDisableReason["FreeBetExpired"] = "FreeBetExpired";
    BetslipDisableReason["FreeBetMinOdds"] = "FreeBetMinOdds";
})(BetslipDisableReason || (BetslipDisableReason = {}));
const BaseBetslipContext = createContext(null);
const DetailedBetslipContext = createContext(null);
const useBaseBetslip = () => {
    return useContext(BaseBetslipContext);
};
const useDetailedBetslip = () => {
    return useContext(DetailedBetslipContext);
};
const BetslipProvider = (props) => {
    const { children, affiliate, isBatchBetWithSameGameEnabled } = props;
    const { prematchClient, liveClient } = useApolloClients();
    const { appChain } = useChain();
    const account = useAccount();
    const { forceUpdate } = useForceUpdate();
    const [items, setItems] = useState([]);
    const [selectedFreeBet, setFreeBet] = useState();
    const [betAmount, setBetAmount] = useState('');
    const [batchBetAmounts, setBatchBetAmounts] = useState({});
    const [isBatch, _setBatch] = useState(false);
    const isBatchRef = useRef(isBatch);
    isBatchRef.current = isBatch;
    const setBatch = useCallback((value) => {
        _setBatch((prevValue) => {
            const newValue = typeof value === 'function' ? value(prevValue) : value;
            isBatchRef.current = newValue;
            return newValue;
        });
    }, []);
    const { data: freeBets, isFetching: isFreeBetsFetching } = useFreeBets({
        account: account.address,
        affiliate: affiliate,
        enabled: Boolean(affiliate),
    });
    const { odds, totalOdds, maxBet, loading: isOddsFetching } = useOdds({ betAmount, batchBetAmounts, selections: items });
    const { statuses, loading: isStatusesFetching } = useStatuses({ selections: items });
    const isCombo = !isBatch && items.length > 1;
    const checkDifferentGames = (items) => {
        const gameIds = items.map(({ game }) => game.gameId);
        return gameIds.length === new Set(gameIds).size;
    };
    const createInitialBatchAmounts = (items) => {
        setBatchBetAmounts(batchAmounts => {
            const newBatchAmounts = {};
            items.forEach(({ conditionId, outcomeId }) => {
                const key = `${conditionId}-${outcomeId}`;
                newBatchAmounts[key] = batchAmounts[key] || '';
            });
            return newBatchAmounts;
        });
    };
    const totalBetAmount = useMemo(() => {
        if (isBatch) {
            return String(Object.values(batchBetAmounts).reduce((acc, amount) => acc + +amount, 0));
        }
        if (selectedFreeBet) {
            return selectedFreeBet.amount;
        }
        return betAmount;
    }, [isBatch, betAmount, batchBetAmounts, selectedFreeBet]);
    const isLiveBet = useMemo(() => {
        return items.some(({ coreAddress }) => coreAddress === liveHostAddress);
    }, [items]);
    const isConditionsInCreatedStatus = useMemo(() => {
        return Object.values(statuses).every(status => status === ConditionStatus.Created);
    }, [statuses]);
    const isComboWithDifferentGames = useMemo(() => {
        return !isCombo || checkDifferentGames(items);
    }, [isCombo, items]);
    const isBatchAllowed = !isBatch || !isLiveBet;
    const isFreeBetAllowed = useMemo(() => {
        if (!selectedFreeBet || !totalOdds) {
            return true;
        }
        return (!isCombo && !isBatch && !isLiveBet
            && selectedFreeBet.expiresAt > Date.now()
            && totalOdds >= parseFloat(selectedFreeBet.minOdds));
    }, [selectedFreeBet, isCombo, isBatch, isLiveBet, totalOdds]);
    const isComboAllowed = useMemo(() => {
        return !isCombo || !isLiveBet && isComboWithDifferentGames && items.every(({ isExpressForbidden }) => !isExpressForbidden);
    }, [isCombo, items]);
    const isPrematchBetAllowed = useMemo(() => {
        return items.every(({ coreAddress, game: { startsAt } }) => {
            if (coreAddress === liveHostAddress) {
                return true;
            }
            return startsAt * 1000 > Date.now();
        });
    }, [items]);
    const minBet = isLiveBet && !appChain?.testnet ? MIN_LIVE_BET_AMOUNT : undefined;
    const isAmountLowerThanMaxBet = Boolean(betAmount) && typeof maxBet !== 'undefined' ? +betAmount <= maxBet : true;
    const isAmountBiggerThanMinBet = Boolean(betAmount) && typeof minBet !== 'undefined' ? +betAmount >= minBet : true;
    const isBetAllowed = (isConditionsInCreatedStatus
        && isComboAllowed
        && isBatchAllowed
        && isPrematchBetAllowed
        && isFreeBetAllowed
        && isAmountLowerThanMaxBet
        && isAmountBiggerThanMinBet);
    let disableReason = (() => {
        if (!isConditionsInCreatedStatus) {
            return BetslipDisableReason.ConditionStatus;
        }
        if (!isFreeBetAllowed) {
            if (isLiveBet) {
                return BetslipDisableReason.FreeBetWithLive;
            }
            else {
                if (isCombo) {
                    return BetslipDisableReason.FreeBetWithCombo;
                }
                if (isBatch) {
                    return BetslipDisableReason.FreeBetWithBatch;
                }
            }
            if (selectedFreeBet.expiresAt <= Date.now()) {
                return BetslipDisableReason.FreeBetExpired;
            }
            if (totalOdds < parseFloat(selectedFreeBet.minOdds)) {
                return BetslipDisableReason.FreeBetMinOdds;
            }
        }
        if (!isComboAllowed) {
            if (isLiveBet) {
                return BetslipDisableReason.ComboWithLive;
            }
            else if (!isComboWithDifferentGames) {
                return BetslipDisableReason.ComboWithSameGame;
            }
            else {
                return BetslipDisableReason.ComboWithForbiddenItem;
            }
        }
        if (!isPrematchBetAllowed) {
            return BetslipDisableReason.PrematchConditionInStartedGame;
        }
        if (!isBatchAllowed) {
            return BetslipDisableReason.BatchWithLive;
        }
        if (!isAmountLowerThanMaxBet) {
            return BetslipDisableReason.BetAmountGreaterThanMaxBet;
        }
        if (!isAmountBiggerThanMinBet) {
            return BetslipDisableReason.BetAmountLowerThanMinBet;
        }
    })();
    const changeBatch = useCallback((value) => {
        setBatch(value);
        if (value) {
            setBetAmount('');
            createInitialBatchAmounts(items);
        }
        else {
            setBatchBetAmounts({});
        }
    }, [items]);
    const changeBetAmount = useCallback((value) => {
        setBetAmount(formatBetValue(value));
    }, []);
    const changeBatchBetAmount = useCallback((item, value) => {
        const { conditionId, outcomeId } = item;
        const key = `${conditionId}-${outcomeId}`;
        setBatchBetAmounts(amounts => {
            return {
                ...amounts,
                [key]: formatBetValue(value),
            };
        });
    }, []);
    const addItem = useCallback((itemProps) => {
        const { gameId, coreAddress, lpAddress, conditionId, outcomeId } = itemProps;
        let game;
        let cache;
        let gameEntityId;
        if (coreAddress === liveHostAddress) {
            cache = liveClient.cache;
            gameEntityId = gameId;
        }
        else {
            cache = prematchClient.cache;
            gameEntityId = `${lpAddress.toLowerCase()}_${gameId}`;
        }
        game = cache.readFragment({
            id: cache.identify({ __typename: 'Game', id: gameEntityId }),
            fragment: MainGameInfoFragmentDoc,
            fragmentName: 'MainGameInfo',
        });
        if (!game) {
            return;
        }
        let marketName = getMarketName({ outcomeId });
        let selectionName = getSelectionName({ outcomeId, withPoint: true });
        if (coreAddress !== liveHostAddress) {
            const conditionEntityId = `${coreAddress.toLowerCase()}_${conditionId}`;
            const condition = cache.readFragment({
                id: cache.identify({ __typename: 'Condition', id: conditionEntityId }),
                fragment: PrematchConditionFragmentDoc,
                fragmentName: 'PrematchCondition',
            });
            if (condition?.title && condition.title !== 'null') {
                marketName = condition.title;
                const outcome = condition.outcomes.find(outcome => outcome.outcomeId === outcomeId);
                if (outcome?.title && outcome.title !== 'null') {
                    selectionName = outcome.title;
                }
            }
        }
        const { participants, startsAt: _startsAt, title, sport: { sportId: _sportId, slug: sportSlug, name: sportName, }, league: { name: leagueName, slug: leagueSlug, country: { name: countryName, slug: countrySlug, }, }, } = game;
        const item = {
            ...itemProps,
            marketName,
            selectionName,
            game: {
                gameId,
                title,
                countryName,
                countrySlug,
                leagueName,
                leagueSlug,
                participants,
                startsAt: +_startsAt,
                sportId: +_sportId,
                sportSlug,
                sportName,
            },
        };
        setItems(items => {
            let newItems;
            const replaceIndex = items.findIndex(({ game: { gameId } }) => gameId === item.game.gameId);
            // if cart contains outcome from same game as new item
            // then replace old item
            if (replaceIndex !== -1) {
                if (isBatchBetWithSameGameEnabled) {
                    const { conditionId, outcomeId } = items[replaceIndex];
                    // if it's exactly the same outcome, don't change the state
                    if (conditionId === item.conditionId && outcomeId === item.outcomeId) {
                        return items;
                    }
                    newItems = [...items, item];
                    setBatch(true);
                }
                else {
                    newItems = [...items];
                    newItems[replaceIndex] = item;
                }
            }
            else {
                newItems = [...items, item];
            }
            localStorage.setItem(localStorageKeys.betslipItems, JSON.stringify(newItems));
            if (isBatchRef.current) {
                createInitialBatchAmounts(newItems);
            }
            return newItems;
        });
    }, []);
    const removeItem = useCallback((itemProps) => {
        const { conditionId, outcomeId } = itemProps;
        setItems(items => {
            const newItems = items.filter((item) => !(item.conditionId === conditionId
                && item.outcomeId === outcomeId));
            if (isBatchRef.current && newItems.length < 2) {
                setBatch(false);
                setBatchBetAmounts(batchAmounts => {
                    const lastItem = newItems[0];
                    if (lastItem) {
                        const { conditionId, outcomeId } = lastItem;
                        const amount = batchAmounts[`${conditionId}-${outcomeId}`];
                        if (amount) {
                            setBetAmount(amount);
                        }
                    }
                    return {};
                });
            }
            else {
                setBatchBetAmounts(batchAmounts => {
                    const newBatchAmounts = { ...batchAmounts };
                    delete newBatchAmounts[`${conditionId}-${outcomeId}`];
                    return newBatchAmounts;
                });
            }
            localStorage.setItem(localStorageKeys.betslipItems, JSON.stringify(newItems));
            return newItems;
        });
    }, []);
    const clear = useCallback(() => {
        setItems([]);
        setBatch(false);
        setBatchBetAmounts({});
        setBetAmount('');
        setFreeBet(undefined);
        localStorage.setItem(localStorageKeys.betslipItems, JSON.stringify([]));
    }, []);
    const prevChainId = useRef(appChain.id);
    useEffect(() => {
        if (prevChainId.current !== appChain.id) {
            clear();
            prevChainId.current = appChain.id;
        }
    }, [appChain.id]);
    useEffect(() => {
        let storedItems = JSON.parse(localStorage.getItem(localStorageKeys.betslipItems) || '[]');
        if (!Array.isArray(storedItems)) {
            return;
        }
        const isDifferentGames = checkDifferentGames(storedItems);
        if (!isDifferentGames) {
            setBatch(true);
            createInitialBatchAmounts(storedItems);
        }
        setItems(storedItems);
    }, []);
    useEffect(() => {
        if (!selectedFreeBet || selectedFreeBet.expiresAt <= Date.now()) {
            return;
        }
        const timeout = setTimeout(() => {
            disableReason = BetslipDisableReason.FreeBetExpired;
            forceUpdate();
        }, selectedFreeBet.expiresAt - Date.now());
        return () => {
            clearTimeout(timeout);
        };
    }, [selectedFreeBet]);
    const baseValue = useMemo(() => ({
        items,
        addItem,
        removeItem,
        clear,
    }), [
        items,
        addItem,
        removeItem,
        clear,
    ]);
    const detailedValue = useMemo(() => ({
        betAmount: totalBetAmount,
        batchBetAmounts,
        odds,
        totalOdds,
        maxBet,
        minBet,
        selectedFreeBet,
        freeBets,
        statuses,
        disableReason,
        changeBetAmount,
        changeBatchBetAmount,
        changeBatch,
        selectFreeBet: setFreeBet,
        isBatch,
        isLiveBet,
        isStatusesFetching,
        isOddsFetching,
        isFreeBetsFetching,
        isBetAllowed,
    }), [
        totalBetAmount,
        batchBetAmounts,
        odds,
        totalOdds,
        maxBet,
        minBet,
        selectedFreeBet,
        freeBets,
        statuses,
        disableReason,
        changeBetAmount,
        changeBatchBetAmount,
        changeBatch,
        setFreeBet,
        isBatch,
        isLiveBet,
        isStatusesFetching,
        isOddsFetching,
        isFreeBetsFetching,
        isBetAllowed,
    ]);
    return (jsx(BaseBetslipContext.Provider, { value: baseValue, children: jsx(DetailedBetslipContext.Provider, { value: detailedValue, children: children }) }));
};const useWatchers = () => {
    const { appChain, contracts } = useChain();
    useWatchContractEvent({
        address: contracts.prematchCore.address,
        abi: contracts.prematchCore.abi,
        eventName: 'NewBet',
        chainId: appChain.id,
        onLogs(logs) {
            const log = logs[0];
            const conditionId = log.args.conditionId;
            oddsWatcher.dispatch(conditionId.toString());
        },
    });
    useWatchContractEvent({
        address: contracts.prematchCore.address,
        abi: contracts.prematchCore.abi,
        eventName: 'OddsChanged',
        chainId: appChain.id,
        onLogs(logs) {
            const log = logs[0];
            const conditionId = log.args.conditionId;
            oddsWatcher.dispatch(conditionId.toString());
        },
    });
    useWatchContractEvent({
        address: contracts.prematchCore.address,
        abi: contracts.prematchCore.abi,
        eventName: 'ConditionStopped',
        chainId: appChain.id,
        onLogs(logs) {
            const log = logs[0];
            const conditionId = log.args.conditionId;
            const isStopped = log.args.flag;
            const status = isStopped ? ConditionStatus.Paused : ConditionStatus.Created;
            conditionStatusWatcher.dispatch(conditionId.toString(), status);
        },
    });
};function Watchers() {
    useWatchers();
    return null;
}
const AzuroSDKProvider = (props) => {
    const { children, initialChainId, affiliate, isBatchBetWithSameGameEnabled } = props;
    return (jsx(ChainProvider, { initialChainId: initialChainId, children: jsxs(SocketProvider, { children: [jsx(ApolloProvider, { children: jsx(BetslipProvider, { isBatchBetWithSameGameEnabled: isBatchBetWithSameGameEnabled, affiliate: affiliate, children: children }) }), jsx(Watchers, {})] }) }));
};const LiveContext = createContext(null);
const useLive = () => {
    return useContext(LiveContext);
};
const LiveProvider = (props) => {
    const { children, initialLiveState } = props;
    const { appChain, setAppChainId } = useChain();
    const [isLive, setLive] = useState(liveSupportedChains.includes(appChain.id) && Boolean(initialLiveState));
    useMemo(() => {
        if (!liveSupportedChains.includes(appChain.id) && isLive) {
            setLive(false);
            document.cookie = `${cookieKeys.live}=false;path=/;`;
        }
    }, [appChain]);
    const handleChangeLive = (value) => {
        document.cookie = `${cookieKeys.live}=${value};path=/;`;
        if (value && !liveSupportedChains.includes(appChain.id)) {
            setAppChainId(liveSupportedChains[0]);
        }
        setLive(value);
    };
    const value = {
        isLive,
        changeLive: handleChangeLive,
    };
    return (jsx(LiveContext.Provider, { value: value, children: children }));
};const usePrematchBets = (props) => {
    const { filter, orderBy = Bet_OrderBy.CreatedBlockTimestamp, orderDir = OrderDirection.Asc, } = props;
    const { prematchClient } = useApolloClients();
    const options = useMemo(() => {
        const variables = {
            first: filter.limit || 1000,
            skip: filter.offset,
            orderBy,
            orderDirection: orderDir,
            where: {
                actor: filter.bettor?.toLowerCase(),
            },
        };
        if (filter.type === BetType.Unredeemed) {
            variables.where.isRedeemable = true;
        }
        else if (filter.type === BetType.Accepted) {
            variables.where.status = GraphBetStatus.Accepted;
        }
        else if (filter.type === BetType.Settled) {
            variables.where.status_in = [GraphBetStatus.Resolved, GraphBetStatus.Canceled];
            variables.where.isRedeemable = false;
        }
        if (filter.affiliate) {
            variables.where.affiliate = filter.affiliate;
        }
        return {
            variables,
            ssr: false,
            client: prematchClient,
            skip: !filter.bettor,
            notifyOnNetworkStatusChange: true,
        };
    }, [
        filter.limit,
        filter.offset,
        filter.bettor,
        filter.type,
        filter.affiliate,
        orderBy,
        orderDir,
    ]);
    const { data, loading, error } = useQuery$1(PrematchBetsDocument, options);
    const bets = useMemo(() => {
        if (!data?.bets?.length) {
            return [];
        }
        return data.bets.map((rawBet) => {
            const { tokenId, status, amount, odds, settledOdds, createdAt, result, affiliate, core: { address: coreAddress, liquidityPool: { address: lpAddress } }, payout: _payout, isRedeemed: _isRedeemed, isRedeemable, freebet, txHash, selections, } = rawBet;
            const isWin = result === BetResult.Won;
            const isLose = result === BetResult.Lost;
            const isCanceled = status === GraphBetStatus.Canceled;
            // express bets have a specific feature - protocol redeems LOST expresses to release liquidity,
            // so we should validate it by "win"/"canceled" statuses
            const isRedeemed = (isWin || isCanceled) && _isRedeemed;
            const isFreebet = Boolean(freebet);
            const freebetId = freebet?.freebetId;
            const freebetContractAddress = freebet?.contractAddress;
            const payout = isRedeemable && isWin ? +_payout : null;
            const betDiff = isFreebet ? amount : 0; // for freebet we must exclude bonus value from possible win
            const totalOdds = settledOdds ? +settledOdds : +odds;
            const possibleWin = +amount * totalOdds - +betDiff;
            const outcomes = selections
                .map((selection) => {
                const { odds, result, outcome: { outcomeId, title: customSelectionName, condition: { conditionId, status: conditionStatus, title: customMarketName, game, }, }, } = selection;
                const isWin = result ? result === SelectionResult.Won : null;
                const isLose = result ? result === SelectionResult.Lost : null;
                const isCanceled = (conditionStatus === ConditionStatus.Canceled
                    || game.status === PrematchGraphGameStatus.Canceled);
                const marketName = customMarketName && customMarketName !== 'null' ? customMarketName : getMarketName({ outcomeId });
                const selectionName = customSelectionName && customSelectionName !== 'null' ? customSelectionName : getSelectionName({ outcomeId, withPoint: true });
                return {
                    selectionName,
                    outcomeId,
                    conditionId,
                    coreAddress,
                    odds: +odds,
                    marketName,
                    game,
                    isWin,
                    isLose,
                    isCanceled,
                };
            })
                .sort((a, b) => +a.game.startsAt - +b.game.startsAt);
            const bet = {
                affiliate: affiliate,
                tokenId,
                freebetContractAddress: freebetContractAddress,
                freebetId,
                txHash,
                totalOdds,
                status,
                amount,
                possibleWin,
                payout,
                createdAt: +createdAt,
                isWin,
                isLose,
                isRedeemable,
                isRedeemed,
                isCanceled,
                coreAddress: coreAddress,
                lpAddress: lpAddress,
                outcomes,
                isLive: false,
            };
            return bet;
        });
    }, [data]);
    return {
        loading,
        bets,
        error,
    };
};const useLiveBets = (props) => {
    const { filter, orderBy = Bet_OrderBy.CreatedBlockTimestamp, orderDir = OrderDirection.Asc, } = props;
    const { prematchClient, liveClient } = useApolloClients();
    const [bets, setBets] = useState([]);
    const [isGamesFetching, setGamesFetching] = useState(true);
    const options = useMemo(() => {
        const variables = {
            first: filter.limit || 1000,
            skip: filter.offset,
            orderBy,
            orderDirection: orderDir,
            where: {
                actor: filter.bettor?.toLowerCase(),
            },
        };
        if (filter.type === BetType.Unredeemed) {
            variables.where.isRedeemable = true;
        }
        else if (filter.type === BetType.Accepted) {
            variables.where.status = GraphBetStatus.Accepted;
        }
        else if (filter.type === BetType.Settled) {
            variables.where.status_in = [GraphBetStatus.Resolved, GraphBetStatus.Canceled];
            variables.where.isRedeemable = false;
        }
        if (filter.affiliate) {
            variables.where.affiliate = filter.affiliate;
        }
        return {
            variables,
            ssr: false,
            client: prematchClient,
            skip: !filter.bettor,
            notifyOnNetworkStatusChange: true,
        };
    }, [
        filter.limit,
        filter.offset,
        filter.bettor,
        filter.type,
        filter.affiliate,
        orderBy,
        orderDir,
    ]);
    const { data, loading: isBetsFetching, error } = useQuery$1(LiveBetsDocument, options);
    const { liveBets } = data || { liveBets: [] };
    const formattedBets = useMemo(() => {
        if (!liveBets.length) {
            return [];
        }
        return liveBets.map((rawBet) => {
            const { tokenId, status, amount, odds, settledOdds, createdAt, result, affiliate, core: { address: coreAddress, liquidityPool: { address: lpAddress } }, payout: _payout, isRedeemed: _isRedeemed, isRedeemable, txHash, selections, } = rawBet;
            const isWin = result === BetResult.Won;
            const isLose = result === BetResult.Lost;
            const isCanceled = status === GraphBetStatus.Canceled;
            // express bets have a specific feature - protocol redeems LOST expresses to release liquidity,
            // so we should validate it by "win"/"canceled" statuses
            const isRedeemed = (isWin || isCanceled) && _isRedeemed;
            const payout = isRedeemable && isWin ? +_payout : null;
            const totalOdds = settledOdds ? +settledOdds : +odds;
            const possibleWin = +amount * totalOdds;
            const outcomes = selections
                .map((selection) => {
                const { odds, result, outcome: { outcomeId, condition: { conditionId, status: conditionStatus, gameId } } } = selection;
                const isWin = result ? result === SelectionResult.Won : null;
                const isLose = result ? result === SelectionResult.Lost : null;
                const isCanceled = conditionStatus === ConditionStatus.Canceled;
                const marketName = getMarketName({ outcomeId });
                const selectionName = getSelectionName({ outcomeId, withPoint: true });
                return {
                    selectionName,
                    outcomeId,
                    conditionId,
                    coreAddress,
                    odds: +odds,
                    marketName,
                    gameId,
                    isWin,
                    isLose,
                    isCanceled,
                };
            });
            const bet = {
                affiliate: affiliate,
                tokenId,
                txHash,
                totalOdds,
                status,
                amount,
                possibleWin,
                payout,
                createdAt: +createdAt,
                isWin,
                isLose,
                isRedeemable,
                isRedeemed,
                isCanceled,
                coreAddress: coreAddress,
                lpAddress: lpAddress,
                outcomes,
                isLive: true,
            };
            return bet;
        });
    }, [liveBets]);
    useEffect(() => {
        if (!formattedBets.length) {
            setGamesFetching(false);
            return;
        }
        (async () => {
            let games = {};
            const needToGetGames = new Set();
            formattedBets.forEach(({ outcomes }) => {
                const gameId = outcomes[0]?.gameId;
                const game = liveClient.cache.readFragment({
                    id: liveClient.cache.identify({ __typename: 'Game', id: gameId }),
                    fragment: MainGameInfoFragmentDoc,
                    fragmentName: 'MainGameInfo',
                });
                if (game) {
                    games[gameId] = game;
                }
                else {
                    needToGetGames.add(gameId);
                }
            });
            if (needToGetGames.size) {
                const { data: { games: _games } } = await liveClient.query({
                    query: GamesDocument,
                    variables: {
                        where: {
                            gameId_in: [...needToGetGames],
                        },
                    },
                    fetchPolicy: 'network-only',
                });
                const fetchedGames = _games.reduce((acc, game) => {
                    acc[game.gameId] = game;
                    return acc;
                }, {});
                games = {
                    ...games,
                    ...fetchedGames,
                };
            }
            const betsWithGames = formattedBets.map(bet => {
                const gameId = bet.outcomes[0]?.gameId;
                const game = games[gameId];
                if (game) {
                    return {
                        ...bet,
                        outcomes: [{
                                ...bet.outcomes[0],
                                game,
                            }],
                    };
                }
            }).filter(Boolean);
            setGamesFetching(false);
            setBets(betsWithGames);
        })();
        return () => {
            setBets([]);
        };
    }, [formattedBets]);
    return {
        loading: isBetsFetching || isGamesFetching,
        bets,
        error,
    };
};const defaultQueryProps = {
    pollInterval: undefined,
    skip: false,
};
const useConditions = (props) => {
    const { gameId, filter, prematchQuery = defaultQueryProps, liveQuery = defaultQueryProps } = props;
    const { prematchClient, liveClient } = useApolloClients();
    const { appChain } = useChain();
    const variables = useMemo(() => {
        const vars = {
            where: {
                game_: {
                    gameId,
                },
                ...(filter || {}),
            },
        };
        return vars;
    }, [gameId, filter]);
    const { data: prematchData, loading: isPrematchLoading, error: prematchError, } = useQuery$1(PrematchConditionsDocument, {
        variables: variables,
        ssr: false,
        client: prematchClient,
        notifyOnNetworkStatusChange: true,
        ...prematchQuery,
    });
    const { data: liveData, loading: isLiveLoading, error: liveError, } = useQuery$1(LiveConditionsDocument, {
        variables: variables,
        ssr: false,
        client: liveClient,
        ...liveQuery,
        skip: liveQuery.skip || !liveSupportedChains.includes(appChain.id),
    });
    return {
        prematchConditions: prematchData?.conditions,
        liveConditions: liveData?.conditions,
        loading: isPrematchLoading || isLiveLoading,
        error: prematchError || liveError,
    };
};const useActiveConditions = (props) => {
    const { gameId, isLive, livePollInterval, filter, fetchPolicy } = props;
    const conditionsFilter = useMemo(() => {
        const _filter = {
            status_not: ConditionStatus.Resolved,
        };
        if (filter?.outcomeIds) {
            _filter.outcomesIds_contains = filter.outcomeIds;
        }
        if (filter?.maxMargin) {
            _filter.margin_lte = parseUnits(String(filter.maxMargin), MARGIN_DECIMALS).toString();
        }
        return _filter;
    }, [filter?.outcomeIds, filter?.maxMargin]);
    const { prematchConditions, liveConditions, loading, error } = useConditions({
        gameId,
        filter: conditionsFilter,
        prematchQuery: {
            skip: isLive,
            fetchPolicy,
        },
        liveQuery: {
            pollInterval: livePollInterval,
            skip: !isLive,
            fetchPolicy,
        },
    });
    const conditions = isLive ? liveConditions : prematchConditions;
    return {
        conditions,
        loading,
        error,
    };
};const useGame = (props) => {
    const { gameId } = props;
    const { prematchClient, liveClient } = useApolloClients();
    const variables = useMemo(() => ({
        gameId: gameId,
    }), [gameId]);
    const { data: prematchData, loading: isPrematchLoading, error: prematchError } = useQuery$1(GameDocument, {
        variables,
        ssr: false,
        client: prematchClient,
        skip: !gameId,
    });
    const { data: liveData, loading: isLiveLoading, error: liveError } = useQuery$1(GameDocument, {
        variables,
        ssr: false,
        client: liveClient,
        skip: !gameId,
    });
    const prematchGame = prematchData?.games?.[0];
    const liveGame = liveData?.games?.[0];
    const game = liveGame || prematchGame;
    const isGameInLive = Boolean(liveGame);
    return {
        game,
        loading: isPrematchLoading || isLiveLoading,
        error: prematchError || liveError,
        isGameInLive,
    };
};const useActiveMarkets = (props) => {
    const { gameId, gameStatus, filter, livePollInterval, fetchPolicy } = props;
    const { loading, conditions, error } = useActiveConditions({
        gameId,
        filter,
        isLive: gameStatus === GameStatus.Live,
        livePollInterval,
        fetchPolicy,
    });
    // generate unique key for memo deps
    const conditionIds = conditions?.map(({ id, outcomes }) => `${id}-${outcomes.length}`).join('_');
    const markets = useMemo(() => {
        if (!conditions?.length) {
            return [];
        }
        return groupConditionsByMarket(conditions);
    }, [conditionIds]);
    return {
        loading,
        markets,
        error,
    };
};const useResolvedMarkets = (props) => {
    const { gameId } = props;
    const { loading, liveConditions, prematchConditions, error } = useConditions({
        gameId,
        filter: {
            status: ConditionStatus.Resolved,
        },
    });
    const prematchConditionIds = prematchConditions?.map(({ id, outcomes }) => `${id}-${outcomes.length}`).join('_');
    const liveConditionIds = liveConditions?.map(({ id, outcomes }) => `${id}-${outcomes.length}`).join('_');
    const prematchMarkets = useMemo(() => {
        if (!prematchConditions?.length) {
            return [];
        }
        return groupConditionsByMarket(prematchConditions);
    }, [prematchConditionIds]);
    const liveMarkets = useMemo(() => {
        if (!liveConditions?.length) {
            return [];
        }
        return groupConditionsByMarket(liveConditions);
    }, [liveConditionIds]);
    const groupedMarkets = useMemo(() => {
        if (!prematchMarkets?.length || !liveMarkets?.length) {
            if (prematchMarkets?.length) {
                return prematchMarkets;
            }
            if (liveMarkets?.length) {
                return liveMarkets;
            }
        }
        return Object.values([...liveMarkets, ...prematchMarkets].reduce((acc, market) => {
            const { marketKey } = market;
            if (!acc[marketKey]) {
                acc[marketKey] = market;
            }
            return acc;
        }, {}));
    }, [prematchMarkets, liveMarkets]);
    return {
        groupedMarkets,
        prematchMarkets,
        liveMarkets,
        loading,
        error,
    };
};const useGames = (props) => {
    const { filter, orderBy = Game_OrderBy.CreatedBlockTimestamp, orderDir = OrderDirection.Desc, isLive, } = props || {};
    const { prematchClient, liveClient } = useApolloClients();
    const startsAt = getGameStartsAtValue();
    const options = useMemo(() => {
        const variables = {
            first: 1000,
            orderBy,
            orderDirection: orderDir,
            where: {
                hasActiveConditions: true,
                status_in: [PrematchGraphGameStatus.Created, PrematchGraphGameStatus.Paused],
            },
        };
        if (isLive) {
            variables.where.startsAt_lt = startsAt;
        }
        else {
            variables.where.startsAt_gt = startsAt;
        }
        if (filter?.limit) {
            variables.first = filter.limit;
        }
        if (filter?.offset) {
            variables.skip = filter.offset;
        }
        if (filter?.sportHub) {
            variables.where.sport_ = {
                sporthub: filter.sportHub,
            };
        }
        if (filter?.sportSlug) {
            variables.where.sport_ = {
                slug_starts_with_nocase: filter.sportSlug,
            };
        }
        if (filter?.leagueSlug) {
            variables.where.league_ = {
                slug_ends_with_nocase: filter.leagueSlug,
            };
        }
        if (filter?.maxMargin) {
            variables.where.conditions_ = {
                margin_lte: parseUnits(String(filter.maxMargin), MARGIN_DECIMALS).toString(),
            };
        }
        return {
            variables,
            ssr: false,
            client: isLive ? liveClient : prematchClient,
            notifyOnNetworkStatusChange: true,
        };
    }, [
        filter?.limit,
        filter?.offset,
        filter?.sportSlug,
        filter?.sportHub,
        filter?.leagueSlug,
        filter?.maxMargin,
        orderBy,
        orderDir,
        startsAt,
        isLive,
    ]);
    const { data, loading, error } = useQuery$1(GamesDocument, options);
    return {
        games: data?.games,
        loading,
        error,
    };
};const useSports = (props) => {
    const { filter, gameOrderBy = Game_OrderBy.StartsAt, orderDir = OrderDirection.Asc, isLive, } = props || {};
    const { prematchClient, liveClient } = useApolloClients();
    const { contracts } = useChain();
    const startsAt = getGameStartsAtValue();
    const options = useMemo(() => {
        const variables = {
            first: filter?.limit || 1000,
            sportFilter: {},
            countryFilter: {},
            leagueFilter: {},
            gameFilter: {
                hasActiveConditions: true,
                status_in: [PrematchGraphGameStatus.Created, PrematchGraphGameStatus.Paused],
            },
            gameOrderBy,
            gameOrderDirection: orderDir,
        };
        if (filter?.sportSlug) {
            variables.sportFilter.slug = filter.sportSlug;
        }
        if (filter?.sportHub) {
            variables.sportFilter.sporthub = filter.sportHub;
        }
        if (filter?.countrySlug) {
            variables.countryFilter.slug = filter.countrySlug;
        }
        if (isLive) {
            variables.gameFilter.startsAt_lt = startsAt;
        }
        else {
            variables.gameFilter.startsAt_gt = startsAt;
            variables.gameFilter.liquidityPool = contracts.lp.address.toLowerCase();
        }
        variables.leagueFilter.games_ = variables.gameFilter;
        if (filter?.leagueSlug) {
            variables.leagueFilter.slug = filter.leagueSlug;
        }
        return {
            variables,
            ssr: false,
            client: isLive ? liveClient : prematchClient,
            notifyOnNetworkStatusChange: true,
        };
    }, [
        isLive,
        contracts.lp.address,
        gameOrderBy,
        orderDir,
        filter?.limit,
        filter?.sportHub,
        filter?.sportSlug,
        filter?.countrySlug,
        filter?.leagueSlug,
        startsAt,
    ]);
    const { data, loading, error } = useQuery$1(SportsDocument, options);
    const { sports } = data || { sports: [] };
    const formattedSports = useMemo(() => {
        if (!sports.length) {
            return [];
        }
        const filteredSports = sports.map(sport => {
            const { countries } = sport;
            const filteredCountries = countries.filter(({ leagues }) => leagues.length);
            return {
                ...sport,
                countries: filteredCountries,
            };
        }).filter(sport => sport.countries.length);
        if (gameOrderBy === Game_OrderBy.Turnover) {
            const sportsWithTurnover = filteredSports.map(sport => {
                const { countries } = sport;
                const turnover = countries.reduce((acc, { turnover }) => {
                    acc += +turnover;
                    return acc;
                }, 0);
                return {
                    ...sport,
                    turnover,
                };
            });
            return sportsWithTurnover.sort((a, b) => b.turnover - a.turnover);
        }
        if (gameOrderBy === Game_OrderBy.StartsAt) {
            return filteredSports.map(sport => {
                const { countries } = sport;
                const sortedCountries = countries.map(country => {
                    const { leagues } = country;
                    return {
                        ...country,
                        leagues: [...leagues].sort((a, b) => +a.games[0].startsAt - +b.games[0].startsAt),
                    };
                }).sort((a, b) => +a.leagues[0].games[0].startsAt - +b.leagues[0].games[0].startsAt);
                return {
                    ...sport,
                    countries: sortedCountries,
                };
            }).sort((a, b) => +a.countries[0].leagues[0].games[0].startsAt - +b.countries[0].leagues[0].games[0].startsAt);
        }
        return filteredSports;
    }, [sports]);
    return {
        loading,
        sports: formattedSports,
        error,
    };
};const useSportsNavigation = (props = {}) => {
    const { filter, withGameCount = false, isLive } = props;
    const { prematchClient, liveClient } = useApolloClients();
    const startsAt = getGameStartsAtValue();
    const options = useMemo(() => {
        const variables = {
            first: 1000,
            withGameCount,
            sportFilter: {},
            gameFilter: {
                hasActiveConditions: true,
                status_in: [PrematchGraphGameStatus.Created, PrematchGraphGameStatus.Paused],
            },
        };
        if (isLive) {
            variables.gameFilter.startsAt_lt = startsAt;
        }
        else {
            variables.gameFilter.startsAt_gt = startsAt;
        }
        if (filter?.sportHub) {
            variables.sportFilter.sporthub = filter.sportHub;
        }
        return {
            variables,
            ssr: false,
            client: isLive ? liveClient : prematchClient,
            notifyOnNetworkStatusChange: true,
        };
    }, [withGameCount, startsAt, isLive, filter?.sportHub]);
    const { data, loading, error } = useQuery$1(SportsNavigationDocument, options);
    return {
        sports: data?.sports,
        loading,
        error,
    };
};const useNavigation = (props = {}) => {
    const { filter, withGameCount = false, isLive } = props;
    const { prematchClient, liveClient } = useApolloClients();
    const startsAt = getGameStartsAtValue();
    const options = useMemo(() => {
        const variables = {
            first: 1000,
            withGameCount,
            sportFilter: {},
            gameFilter: {
                hasActiveConditions: true,
                status_in: [PrematchGraphGameStatus.Created, PrematchGraphGameStatus.Paused],
            },
        };
        if (isLive) {
            variables.gameFilter.startsAt_lt = startsAt;
        }
        else {
            variables.gameFilter.startsAt_gt = startsAt;
        }
        if (filter?.sportHub) {
            variables.sportFilter.sporthub = filter.sportHub;
        }
        return {
            variables,
            ssr: false,
            client: isLive ? liveClient : prematchClient,
            notifyOnNetworkStatusChange: true,
        };
    }, [withGameCount, startsAt, isLive, filter?.sportHub]);
    const { data, loading, error } = useQuery$1(NavigationDocument, options);
    return {
        navigation: data?.sports,
        loading,
        error,
    };
};const useLiveBetFee = ({ enabled } = { enabled: true }) => {
    const { appChain } = useChain();
    const queryFn = async () => {
        const { gasAmount, relayerFeeAmount, beautyRelayerFeeAmount, } = await getLiveBetFee(appChain.id);
        return {
            gasAmount: BigInt(gasAmount),
            relayerFeeAmount: BigInt(relayerFeeAmount),
            formattedRelayerFeeAmount: beautyRelayerFeeAmount,
        };
    };
    let { isFetching, data, refetch } = useQuery({
        queryKey: ['/live-bet-fee', appChain.id],
        queryFn,
        enabled,
        refetchOnWindowFocus: false,
        refetchInterval: 10000,
    });
    if (!enabled) {
        data = undefined;
    }
    return {
        gasAmount: data?.gasAmount,
        relayerFeeAmount: data?.relayerFeeAmount,
        formattedRelayerFeeAmount: data?.formattedRelayerFeeAmount,
        refetch,
        loading: isFetching,
    };
};const useBetsSummary = (props) => {
    const { account, affiliates } = props;
    const { betToken } = useChain();
    const { prematchClient } = useApolloClients();
    const options = useMemo(() => {
        const variables = {
            where: {
                address: account?.toLowerCase(),
            },
        };
        if (affiliates?.length) {
            variables.where.affiliate_in = affiliates.map(affiliate => affiliate.toLowerCase());
        }
        return {
            variables,
            ssr: false,
            client: prematchClient,
            notifyOnNetworkStatusChange: true,
            skip: !account,
        };
    }, [
        account,
        affiliates?.join('-'),
    ]);
    const { data, loading, error } = useQuery$1(BettorsDocument, options);
    const { bettors } = data || { bettors: [] };
    const formattedData = useMemo(() => {
        if (!bettors.length) {
            return {
                toPayout: '0',
                inBets: '0',
                totalPayout: '0',
                totalProfit: '0',
                betsCount: 0,
                wonBetsCount: 0,
                lostBetsCount: 0,
            };
        }
        const { rawToPayout, rawInBets, rawTotalPayout, rawTotalProfit, betsCount, wonBetsCount, lostBetsCount, } = bettors.reduce((acc, bettor) => {
            const { rawToPayout, rawInBets, rawTotalPayout, rawTotalProfit, betsCount, wonBetsCount, lostBetsCount } = bettor;
            acc.rawToPayout += BigInt(rawToPayout);
            acc.rawInBets += BigInt(rawInBets);
            acc.rawTotalPayout += BigInt(rawTotalPayout);
            acc.rawTotalProfit += BigInt(rawTotalProfit);
            acc.betsCount += betsCount;
            acc.wonBetsCount += wonBetsCount;
            acc.lostBetsCount += lostBetsCount;
            return acc;
        }, {
            rawToPayout: 0n,
            rawInBets: 0n,
            rawTotalPayout: 0n,
            rawTotalProfit: 0n,
            betsCount: 0,
            wonBetsCount: 0,
            lostBetsCount: 0,
        });
        return {
            toPayout: formatUnits(rawToPayout, betToken.decimals),
            inBets: formatUnits(rawInBets, betToken.decimals),
            totalPayout: formatUnits(rawTotalPayout, betToken.decimals),
            totalProfit: formatUnits(rawTotalProfit, betToken.decimals),
            betsCount,
            wonBetsCount,
            lostBetsCount,
        };
    }, [data]);
    return {
        ...formattedData,
        loading,
        error,
    };
};const DIVIDER = 18;
const useBetsSummaryBySelection = ({ account, gameId, gameStatus, keyStruct = 'outcomeId' }) => {
    const { prematchClient } = useApolloClients();
    const { betToken } = useChain();
    const variables = useMemo(() => ({
        actor: account?.toLowerCase(),
        gameId,
    }), [account, gameId]);
    const { data, loading, error } = useQuery$1(GameBetsDocument, {
        variables,
        ssr: false,
        client: prematchClient,
        skip: !account || gameStatus !== GameStatus.Resolved,
    });
    const { bets: prematchBets, liveBets } = data || {};
    const betsSummary = useMemo(() => {
        if (!prematchBets?.length && !liveBets?.length) {
            return {};
        }
        const rawOne = parseUnits('1', ODDS_DECIMALS);
        const rawSummary = [...(prematchBets || []), ...(liveBets || [])].reduce((acc, bet) => {
            const { rawAmount: _rawAmount, rawPotentialPayout: _rawPotentialPayout, result, selections } = bet;
            const { freebet } = bet;
            const isExpress = selections.length > 1;
            const isWin = result === BetResult.Won;
            const rawAmount = BigInt(_rawAmount);
            const rawBetDiff = freebet ? rawAmount : 0n;
            const rawPayout = BigInt(_rawPotentialPayout) - rawBetDiff;
            let rawOddsSummary = 0n;
            if (isExpress) {
                selections.forEach(selection => {
                    const { rawOdds } = selection;
                    rawOddsSummary += BigInt(rawOdds) - rawOne;
                });
            }
            selections.forEach(selection => {
                const { outcome: { outcomeId, condition: { conditionId } } } = selection;
                if (isExpress) {
                    const { outcome: { condition: { game: { gameId: _gameId } } } } = selection;
                    if (gameId !== _gameId) {
                        return;
                    }
                }
                let key = outcomeId;
                if (keyStruct === 'conditionId-outcomeId') {
                    key = `${conditionId}-${outcomeId}`;
                }
                if (!acc[key]) {
                    acc[key] = 0n;
                }
                if (isExpress) {
                    const { rawOdds } = selection;
                    const rawSubBetOdds = parseUnits(String(BigInt(rawOdds) - rawOne), DIVIDER);
                    const rawSubBetAmount = rawAmount * (rawSubBetOdds / rawOddsSummary);
                    acc[key] += isWin ? rawSubBetAmount * BigInt(rawOdds) : -rawSubBetAmount;
                }
                else {
                    acc[key] += parseUnits(String(isWin ? rawPayout : -rawAmount), DIVIDER);
                }
            });
            return acc;
        }, {});
        return Object.keys(rawSummary).reduce((acc, key) => {
            acc[key] = formatUnits(rawSummary[key], betToken.decimals + DIVIDER);
            return acc;
        }, {});
    }, [prematchBets, liveBets]);
    return {
        betsSummary,
        loading,
        error,
    };
};const useBetsCache = () => {
    const { prematchClient, liveClient } = useApolloClients();
    const { contracts, betToken } = useChain();
    const { address } = useAccount();
    const updateBetCache = ({ coreAddress, tokenId }, values) => {
        const isLive = contracts.liveCore ? coreAddress.toLowerCase() === contracts.liveCore.address.toLowerCase() : false;
        const { cache } = prematchClient;
        const betEntityId = `${coreAddress.toLowerCase()}_${tokenId}`;
        let bet;
        if (isLive) {
            bet = cache.updateFragment({
                id: cache.identify({ __typename: 'LiveBet', id: betEntityId }),
                fragment: LiveBetFragmentDoc,
                fragmentName: 'LiveBet',
            }, (data) => ({
                ...data,
                ...values,
            }));
        }
        else {
            bet = cache.updateFragment({
                id: cache.identify({ __typename: 'Bet', id: betEntityId }),
                fragment: PrematchBetFragmentDoc,
                fragmentName: 'PrematchBet',
            }, (data) => ({
                ...data,
                ...values,
            }));
        }
        if (!bet) {
            return;
        }
        const bettorEntity = `${contracts.lp.address.toLowerCase()}_${address.toLowerCase()}_${bet.affiliate.toLowerCase()}`;
        prematchClient.cache.updateFragment({
            id: prematchClient.cache.identify({ __typename: 'Bettor', id: bettorEntity }),
            fragment: BettorFragmentDoc,
            fragmentName: 'Bettor',
        }, (data) => {
            if (!data) {
                return data;
            }
            const rawPayout = parseUnits(bet.payout, betToken.decimals);
            const newRawToPayout = BigInt(data.rawToPayout) - rawPayout;
            return {
                ...data,
                rawToPayout: String(newRawToPayout),
            };
        });
    };
    const addBet = async (props) => {
        const { bet, odds, affiliate, receipt } = props;
        const { rawAmount, selections, freebetId } = bet;
        const coreAddress = selections[0].coreAddress;
        const isLive = coreAddress.toLowerCase() === liveHostAddress.toLowerCase();
        const client = isLive ? liveClient : prematchClient;
        const { cache } = client;
        const selectionFragments = [];
        for (let index = 0; index < selections.length; index++) {
            const { outcomeId, conditionId: _conditionId } = selections[index];
            const conditionId = String(_conditionId);
            if (isLive) {
                let condition = cache.readFragment({
                    id: cache.identify({ __typename: 'Condition', id: conditionId }),
                    fragment: LiveConditionFragmentDoc,
                    fragmentName: 'LiveCondition',
                });
                if (!condition) {
                    const { data: { condition: _condition } } = await client.query({
                        query: LiveConditionDocument,
                        variables: {
                            conditionId,
                        },
                        fetchPolicy: 'network-only',
                    });
                    condition = _condition;
                }
                const gameId = condition.game.gameId;
                const selectionFragment = {
                    __typename: 'LiveSelection',
                    odds: String(odds[`${conditionId}-${outcomeId}`]),
                    result: null,
                    outcome: {
                        __typename: 'LiveOutcome',
                        outcomeId: String(outcomeId),
                        condition: {
                            __typename: 'LiveCondition',
                            conditionId,
                            status: ConditionStatus.Created,
                            gameId,
                        },
                    },
                };
                selectionFragments.push(selectionFragment);
            }
            else {
                const conditionEntityId = `${coreAddress.toLowerCase()}_${conditionId}`;
                let condition = cache.readFragment({
                    id: cache.identify({ __typename: 'Condition', id: conditionEntityId }),
                    fragment: PrematchConditionFragmentDoc,
                    fragmentName: 'PrematchCondition',
                });
                if (!condition) {
                    const { data: { condition: _condition } } = await client.query({
                        query: PrematchConditionDocument,
                        variables: {
                            id: conditionEntityId,
                        },
                        fetchPolicy: 'network-only',
                    });
                    condition = _condition;
                }
                const outcome = condition.outcomes.find((outcome) => outcome.outcomeId === outcomeId);
                const gameId = condition?.game.gameId;
                const gameEntityId = `${contracts.lp.address.toLowerCase()}_${gameId}`;
                let game = cache.readFragment({
                    id: cache.identify({ __typename: 'Game', id: gameEntityId }),
                    fragment: MainGameInfoFragmentDoc,
                    fragmentName: 'MainGameInfo',
                });
                if (!game) {
                    const { data: { games } } = await client.query({
                        query: GameDocument,
                        variables: {
                            gameId,
                        },
                        fetchPolicy: 'network-only',
                    });
                    game = games[0];
                }
                const selectionFragment = {
                    __typename: 'Selection',
                    odds: String(odds[`${conditionId}-${outcomeId}`]),
                    result: null,
                    outcome: {
                        __typename: 'Outcome',
                        outcomeId: String(outcomeId),
                        title: outcome.title,
                        condition: {
                            __typename: 'Condition',
                            conditionId,
                            status: ConditionStatus.Created,
                            title: condition.title,
                            game,
                        },
                    },
                };
                selectionFragments.push(selectionFragment);
            }
        }
        let tokenId;
        let rawOdds = 0n;
        if (isLive) {
            const receiptArgs = getEventArgsFromTxReceipt({ receipt, eventName: 'NewLiveBet', abi: liveCoreAbi });
            tokenId = (receiptArgs?.tokenId).toString();
            rawOdds = receiptArgs?.odds;
        }
        // we don't need additional for freeBet cause it triggers NewBet event on prematch core
        else {
            const isExpress = selections.length > 1;
            if (isExpress) {
                const receiptArgs = getEventArgsFromTxReceipt({
                    receipt,
                    eventName: 'NewBet',
                    abi: contracts.prematchComboCore.abi,
                });
                tokenId = receiptArgs?.betId.toString();
                rawOdds = receiptArgs?.bet.odds;
            }
            else {
                const { conditionId, outcomeId } = selections[0];
                const eventParams = {
                    conditionId: BigInt(conditionId),
                    outcomeId: BigInt(outcomeId),
                };
                const receiptArgs = getEventArgsFromTxReceipt({
                    receipt,
                    eventName: 'NewBet',
                    abi: contracts.prematchCore.abi,
                    params: eventParams,
                });
                tokenId = receiptArgs?.tokenId.toString();
                rawOdds = receiptArgs?.odds;
            }
        }
        const rawPotentialPayout = rawAmount * rawOdds;
        const potentialPayout = formatUnits(rawPotentialPayout, betToken.decimals);
        const finalOdds = formatUnits(rawOdds, ODDS_DECIMALS);
        const amount = formatUnits(rawAmount, betToken.decimals);
        const actorArg = `"actor":"${address.toLowerCase()}"`;
        const affiliateArg = `"affiliate":"${affiliate}"`;
        if (isLive) {
            prematchClient.cache.modify({
                id: prematchClient.cache.identify({ __typename: 'Query' }),
                fields: {
                    liveBets: (bets, { storeFieldName }) => {
                        const isValidStorage = (storeFieldName.includes(`{${actorArg}}`) // all bets
                            || storeFieldName.includes(`{${actorArg},${affiliateArg}}`) // all bets with affiliate
                            || (storeFieldName.includes(actorArg) && storeFieldName.includes('"status":"Accepted"')) // BetType.Accepted
                        );
                        if (!isValidStorage) {
                            return bets;
                        }
                        const betEntityId = `${coreAddress.toLowerCase()}_${tokenId}`;
                        const data = {
                            __typename: 'LiveBet',
                            id: betEntityId,
                            tokenId: tokenId,
                            core: {
                                address: coreAddress,
                                liquidityPool: {
                                    address: contracts.lp.address,
                                },
                            },
                            status: GraphBetStatus.Accepted,
                            amount,
                            odds: finalOdds,
                            settledOdds: null,
                            createdAt: String(Math.floor(Date.now() / 1000)),
                            payout: null,
                            potentialPayout: potentialPayout,
                            isRedeemed: false,
                            isRedeemable: false,
                            result: null,
                            txHash: receipt.transactionHash,
                            affiliate,
                            selections: selectionFragments,
                        };
                        const newBet = prematchClient.cache.writeFragment({
                            fragment: LiveBetFragmentDoc,
                            fragmentName: 'LiveBet',
                            data,
                        });
                        return [newBet, ...bets];
                    },
                },
            });
        }
        else {
            prematchClient.cache.modify({
                id: prematchClient.cache.identify({ __typename: 'Query' }),
                fields: {
                    bets: (bets, { storeFieldName }) => {
                        const isValidStorage = (storeFieldName.includes(`{${actorArg}}`) // all bets
                            || storeFieldName.includes(`{${actorArg},${affiliateArg}}`) // all bets with affiliate
                            || (storeFieldName.includes(actorArg) && storeFieldName.includes('"status":"Accepted"')) // BetType.Accepted
                        );
                        if (!isValidStorage) {
                            return bets;
                        }
                        const betEntityId = `${coreAddress.toLowerCase()}_${tokenId}`;
                        const data = {
                            __typename: 'Bet',
                            id: betEntityId,
                            tokenId: tokenId,
                            core: {
                                address: coreAddress,
                                liquidityPool: {
                                    address: contracts.lp.address,
                                },
                            },
                            status: GraphBetStatus.Accepted,
                            amount,
                            odds: finalOdds,
                            settledOdds: null,
                            createdAt: String(Math.floor(Date.now() / 1000)),
                            payout: null,
                            potentialPayout: potentialPayout,
                            isRedeemed: false,
                            isRedeemable: false,
                            freebet: bet.freebetContractAddress ? {
                                freebetId: String(freebetId),
                                contractAddress: bet.freebetContractAddress,
                            } : null,
                            result: null,
                            txHash: receipt.transactionHash,
                            affiliate,
                            selections: selectionFragments,
                        };
                        const newBet = prematchClient.cache.writeFragment({
                            fragment: PrematchBetFragmentDoc,
                            fragmentName: 'PrematchBet',
                            data,
                        });
                        return [newBet, ...bets];
                    },
                },
            });
        }
        const bettorEntity = `${contracts.lp.address.toLowerCase()}_${address.toLowerCase()}_${affiliate.toLowerCase()}`;
        const bettorFragment = cache.readFragment({
            id: cache.identify({ __typename: 'Bettor', id: bettorEntity }),
            fragment: BettorFragmentDoc,
            fragmentName: 'Bettor',
        });
        if (bettorFragment) {
            prematchClient.cache.updateFragment({
                id: prematchClient.cache.identify({ __typename: 'Bettor', id: bettorEntity }),
                fragment: BettorFragmentDoc,
                fragmentName: 'Bettor',
            }, (data) => ({
                ...data,
                betsCount: data.betsCount + 1,
                rawInBets: String(BigInt(data.rawInBets) + rawAmount),
            }));
        }
        else {
            prematchClient.cache.modify({
                id: prematchClient.cache.identify({ __typename: 'Query' }),
                fields: {
                    bettors: (bettors) => {
                        const newBettor = prematchClient.cache.writeFragment({
                            fragment: BettorFragmentDoc,
                            fragmentName: 'Bettor',
                            data: {
                                __typename: 'Bettor',
                                id: bettorEntity,
                                rawToPayout: '0',
                                rawInBets: String(rawAmount),
                                rawTotalPayout: '0',
                                rawTotalProfit: '0',
                                betsCount: 1,
                                wonBetsCount: 0,
                                lostBetsCount: 0,
                            },
                        });
                        return [...bettors, newBettor];
                    },
                },
            });
        }
    };
    return {
        updateBetCache,
        addBet,
    };
};const useRedeemBet = () => {
    const publicClient = usePublicClient();
    const { contracts } = useChain();
    const { updateBetCache } = useBetsCache();
    const redeemTx = useWriteContract();
    const batchRedeemTx = useWriteContract();
    const receipt = useWaitForTransactionReceipt({
        hash: redeemTx.data,
    });
    const batchReceipt = useWaitForTransactionReceipt({
        hash: batchRedeemTx.data,
    });
    const submit = async (props) => {
        const { bets } = props;
        const isBatch = bets.length > 1;
        let hash;
        if (isBatch) {
            const betsData = bets.map(({ tokenId, coreAddress }) => ({
                core: coreAddress,
                tokenId: BigInt(tokenId),
                isNative: false,
            }));
            hash = await batchRedeemTx.writeContractAsync({
                address: contracts.proxyFront.address,
                abi: contracts.proxyFront.abi,
                functionName: 'withdrawPayouts',
                args: [betsData],
            });
        }
        else {
            const { tokenId, coreAddress, freebetContractAddress, freebetId } = bets[0];
            if (freebetContractAddress && freebetId) {
                hash = await redeemTx.writeContractAsync({
                    address: freebetContractAddress,
                    abi: freeBetAbi,
                    functionName: 'withdrawPayout',
                    args: [BigInt(freebetId)],
                });
            }
            else {
                hash = await redeemTx.writeContractAsync({
                    address: contracts.lp.address,
                    abi: contracts.lp.abi,
                    functionName: 'withdrawPayout',
                    args: [
                        coreAddress,
                        BigInt(tokenId),
                    ],
                });
            }
        }
        const receipt = await publicClient.waitForTransactionReceipt({
            hash,
        });
        bets.forEach(({ tokenId, coreAddress }) => {
            updateBetCache({
                coreAddress,
                tokenId,
            }, {
                isRedeemed: true,
                isRedeemable: false,
            });
        });
        return receipt;
    };
    return {
        isPending: redeemTx.isPending || batchRedeemTx.isPending,
        isProcessing: receipt.isLoading || batchReceipt.isLoading,
        data: redeemTx.data || batchRedeemTx.data,
        error: redeemTx.error || batchRedeemTx.error,
        submit,
    };
};var LiveOrderState;
(function (LiveOrderState) {
    LiveOrderState["Created"] = "Created";
    LiveOrderState["Pending"] = "Pending";
    LiveOrderState["Sent"] = "Sent";
    LiveOrderState["Accepted"] = "Accepted";
    LiveOrderState["Rejected"] = "Rejected";
})(LiveOrderState || (LiveOrderState = {}));
const simpleObjReducer = (state, newState) => ({
    ...state,
    ...newState,
});
const usePrepareBet = (props) => {
    const { betAmount: _betAmount, slippage, deadline, affiliate, selections, odds, totalOdds, freeBet, betGas, liveEIP712Attention, onSuccess, onError, } = props;
    const isLiveBet = useMemo(() => {
        return selections.some(({ coreAddress }) => coreAddress === liveHostAddress);
    }, [selections]);
    const isCombo = !isLiveBet && selections.length > 1;
    const isBatch = isCombo && typeof _betAmount === 'object';
    const isFreeBet = Boolean(freeBet) && !isCombo && !isBatch;
    const account = useAccount();
    const queryClient = useQueryClient();
    const publicClient = usePublicClient();
    const walletClient = useWalletClient();
    const { appChain, contracts, betToken, api, environment } = useChain();
    const { relayerFeeAmount: rawRelayerFeeAmount, formattedRelayerFeeAmount: relayerFeeAmount, loading: isRelayerFeeFetching, } = useLiveBetFee({
        enabled: isLiveBet,
    });
    const { addBet } = useBetsCache();
    const { queryKey: balanceQueryKey } = useBalance({
        chainId: appChain.id,
        address: account.address,
        token: betToken.address,
    });
    const [liveBetTx, updateLiveBetTx] = useReducer(simpleObjReducer, { data: undefined, isPending: false });
    const approveAddress = isLiveBet ? contracts.liveRelayer?.address : contracts.proxyFront.address;
    const allowanceTx = useReadContract({
        chainId: appChain.id,
        address: betToken.address,
        abi: erc20Abi,
        functionName: 'allowance',
        args: [
            account.address,
            approveAddress,
        ],
        query: {
            enabled: Boolean(account.address) && Boolean(approveAddress) && !isFreeBet,
        },
    });
    const approveTx = useWriteContract();
    const approveReceipt = useWaitForTransactionReceipt({
        hash: approveTx.data,
    });
    const betAmount = useMemo(() => {
        if (typeof _betAmount === 'string') {
            return +_betAmount;
        }
        return Object.values(_betAmount).reduce((acc, amount) => acc + +amount, 0);
    }, [_betAmount]);
    const isApproveRequired = useMemo(() => {
        if (!betAmount
            || typeof allowanceTx?.data === 'undefined'
            || (isLiveBet && typeof relayerFeeAmount === 'undefined')) {
            return false;
        }
        let approveAmount = betAmount;
        if (isLiveBet) {
            approveAmount += +relayerFeeAmount;
        }
        return allowanceTx.data < parseUnits(String(approveAmount), betToken.decimals);
    }, [allowanceTx.data, isLiveBet, relayerFeeAmount, betAmount]);
    const approve = async () => {
        const hash = await approveTx.writeContractAsync({
            address: betToken.address,
            abi: erc20Abi,
            functionName: 'approve',
            args: [
                approveAddress,
                maxUint256,
            ],
        });
        await publicClient.waitForTransactionReceipt({
            hash,
        });
        allowanceTx.refetch();
    };
    const betTx = useSendTransaction();
    const betReceipt = useWaitForTransactionReceipt({
        hash: betTx.data || liveBetTx.data,
    });
    const placeBet = async () => {
        if (!totalOdds) {
            return;
        }
        let bets = [];
        const fixedAmount = parseFloat(String(betAmount)).toFixed(betToken.decimals);
        const rawAmount = parseUnits(fixedAmount, betToken.decimals);
        const rawDeadline = BigInt(Math.floor(Date.now() / 1000) + (deadline || DEFAULT_DEADLINE));
        let txHash;
        if (isLiveBet) {
            betTx.reset();
        }
        updateLiveBetTx({
            data: undefined,
            isPending: isLiveBet,
        });
        try {
            if (isLiveBet) {
                const fixedMinOdds = calcMindOdds({ odds: totalOdds, slippage });
                const rawMinOdds = parseUnits(fixedMinOdds, ODDS_DECIMALS);
                const { conditionId, outcomeId } = selections[0];
                bets.push({
                    rawAmount,
                    selections,
                });
                const order = {
                    bet: {
                        attention: liveEIP712Attention || 'By signing this transaction, I agree to place a bet for a live event on \'Azuro SDK Example',
                        affiliate,
                        core: contracts.liveCore.address,
                        amount: String(rawAmount),
                        chainId: appChain.id,
                        conditionId: conditionId,
                        outcomeId: +outcomeId,
                        minOdds: String(rawMinOdds),
                        nonce: String(Date.now()),
                        expiresAt: Math.floor(Date.now() / 1000) + 2000,
                        relayerFeeAmount: String(rawRelayerFeeAmount),
                    },
                };
                const EIP712Domain = {
                    name: 'Live Betting',
                    version: '1.0.0',
                    chainId: appChain.id,
                    verifyingContract: contracts.liveCore.address,
                };
                const clientBetDataTypes = {
                    ClientBetData: [
                        { name: 'attention', type: 'string' },
                        { name: 'affiliate', type: 'address' },
                        { name: 'core', type: 'address' },
                        { name: 'amount', type: 'uint128' },
                        { name: 'nonce', type: 'uint256' },
                        { name: 'conditionId', type: 'uint256' },
                        { name: 'outcomeId', type: 'uint64' },
                        { name: 'minOdds', type: 'uint64' },
                        { name: 'expiresAt', type: 'uint256' },
                        { name: 'chainId', type: 'uint256' },
                        { name: 'relayerFeeAmount', type: 'uint256' },
                    ],
                };
                const signature = await walletClient.data.signTypedData({
                    account: account.address,
                    domain: EIP712Domain,
                    primaryType: 'ClientBetData',
                    types: clientBetDataTypes,
                    message: {
                        attention: order.bet.attention,
                        affiliate: order.bet.affiliate,
                        core: order.bet.core,
                        amount: BigInt(order.bet.amount),
                        nonce: BigInt(order.bet.nonce),
                        conditionId: BigInt(order.bet.conditionId),
                        outcomeId: BigInt(order.bet.outcomeId),
                        minOdds: BigInt(order.bet.minOdds),
                        expiresAt: BigInt(order.bet.expiresAt),
                        chainId: BigInt(order.bet.chainId),
                        relayerFeeAmount: BigInt(order.bet.relayerFeeAmount),
                    },
                });
                const signedBet = {
                    environment,
                    bettor: account.address.toLowerCase(),
                    data: order,
                    bettorSignature: signature,
                };
                const createOrderResponse = await fetch(`${api}/orders`, {
                    method: 'POST',
                    headers: {
                        'Accept': 'application/json',
                        'Content-Type': 'application/json',
                    },
                    body: JSON.stringify(signedBet),
                });
                const { id: orderId, state: newOrderState, errorMessage, } = await createOrderResponse.json();
                if (newOrderState === LiveOrderState.Created) {
                    txHash = await new Promise((res, rej) => {
                        const interval = setInterval(async () => {
                            const getOrderResponse = await fetch(`${api}/orders/${orderId}`);
                            const { state, txHash } = await getOrderResponse.json();
                            if (state === LiveOrderState.Rejected) {
                                clearInterval(interval);
                                rej();
                            }
                            if (txHash) {
                                clearInterval(interval);
                                res(txHash);
                            }
                        }, 1000);
                    });
                    updateLiveBetTx({
                        data: txHash,
                        isPending: false,
                    });
                }
                else {
                    throw Error(errorMessage);
                }
            }
            else if (isFreeBet) {
                const { coreAddress, conditionId, outcomeId } = selections[0];
                const { id, expiresAt, contractAddress, rawMinOdds, rawAmount, signature, chainId } = freeBet;
                const fixedSelectionMinOdds = calcMindOdds({ odds: odds[`${conditionId}-${outcomeId}`], slippage });
                const rawSelectionMinOdds = parseUnits(fixedSelectionMinOdds, ODDS_DECIMALS);
                const rawFreeBetMinOdds = rawMinOdds > rawSelectionMinOdds ? rawMinOdds : rawSelectionMinOdds;
                bets.push({
                    rawAmount,
                    selections,
                    freebetContractAddress: contractAddress,
                    freebetId: String(id),
                });
                txHash = await betTx.sendTransactionAsync({
                    to: contractAddress,
                    data: encodeFunctionData({
                        abi: freeBetAbi,
                        functionName: 'bet',
                        args: [
                            {
                                chainId: BigInt(chainId),
                                expiresAt: BigInt(Math.floor(expiresAt / 1000)),
                                amount: rawAmount,
                                freeBetId: BigInt(id),
                                minOdds: rawMinOdds,
                                owner: account.address,
                            },
                            signature,
                            coreAddress,
                            BigInt(conditionId),
                            BigInt(outcomeId),
                            rawDeadline,
                            rawFreeBetMinOdds,
                        ],
                    }),
                    ...(betGas || {}),
                });
            }
            else {
                let betData;
                if (isBatch) {
                    betData = selections.map(selection => {
                        const { conditionId, outcomeId } = selection;
                        const fixedAmount = parseFloat(_betAmount[`${conditionId}-${outcomeId}`]).toFixed(betToken.decimals);
                        const rawAmount = parseUnits(fixedAmount, betToken.decimals);
                        const fixedMinOdds = calcMindOdds({ odds: odds[`${conditionId}-${outcomeId}`], slippage });
                        const rawMinOdds = parseUnits(fixedMinOdds, ODDS_DECIMALS);
                        const data = getPrematchBetDataBytes([selection]);
                        bets.push({
                            rawAmount,
                            selections: [selection],
                        });
                        return {
                            core: contracts.prematchCore.address,
                            amount: rawAmount,
                            expiresAt: rawDeadline,
                            extraData: {
                                affiliate,
                                minOdds: rawMinOdds,
                                data,
                            },
                        };
                    });
                }
                else {
                    const fixedMinOdds = calcMindOdds({ odds: totalOdds, slippage });
                    const rawMinOdds = parseUnits(fixedMinOdds, ODDS_DECIMALS);
                    const coreAddress = selections.length > 1 ? contracts.prematchComboCore.address : contracts.prematchCore.address;
                    const data = getPrematchBetDataBytes(selections);
                    bets.push({
                        rawAmount,
                        selections,
                    });
                    betData = [
                        {
                            core: coreAddress,
                            amount: rawAmount,
                            expiresAt: rawDeadline,
                            extraData: {
                                affiliate,
                                minOdds: rawMinOdds,
                                data,
                            },
                        },
                    ];
                }
                txHash = await betTx.sendTransactionAsync({
                    to: contracts.proxyFront.address,
                    data: encodeFunctionData({
                        abi: contracts.proxyFront.abi,
                        functionName: 'bet',
                        args: [
                            contracts.lp.address,
                            betData,
                        ],
                    }),
                    ...(betGas || {}),
                });
            }
            const receipt = await publicClient?.waitForTransactionReceipt({
                hash: txHash,
            });
            queryClient.invalidateQueries({ queryKey: balanceQueryKey });
            if (isFreeBet) {
                const queryKey = ['freebets', api, account.address.toLowerCase(), affiliate.toLowerCase()];
                await queryClient.cancelQueries({ queryKey });
                queryClient.setQueryData(queryKey, (oldFreeBets) => {
                    const newFreeBets = [...oldFreeBets].filter(({ id, contractAddress }) => {
                        return contractAddress.toLowerCase() !== freeBet.contractAddress.toLowerCase() || id !== freeBet.id;
                    });
                    return newFreeBets;
                });
            }
            if (receipt) {
                bets.forEach((bet) => {
                    addBet({
                        receipt,
                        affiliate,
                        odds,
                        bet,
                    });
                });
            }
            if (onSuccess) {
                onSuccess(receipt);
            }
        }
        catch (err) {
            if (isLiveBet) {
                updateLiveBetTx({
                    isPending: false,
                });
            }
            if (onError) {
                onError(err);
            }
        }
    };
    const submit = () => {
        if (isApproveRequired) {
            return approve();
        }
        return placeBet();
    };
    return {
        submit,
        approveTx: {
            isPending: approveTx.isPending,
            isProcessing: approveReceipt.isLoading,
        },
        betTx: {
            data: betTx.data || liveBetTx.data,
            isPending: betTx.isPending || liveBetTx.isPending,
            isProcessing: betReceipt.isLoading,
        },
        relayerFeeAmount,
        isAllowanceLoading: allowanceTx.isLoading,
        isApproveRequired,
        isRelayerFeeLoading: isRelayerFeeFetching,
    };
};const getOutcomes = async (conditionEntityIds, client) => {
    const result = await client.query({
        query: PrematchConditionsBatchDocument,
        variables: {
            conditionFilter: {
                id_in: conditionEntityIds,
            },
        },
        fetchPolicy: 'network-only',
    });
    return result?.data?.conditions.reduce((acc, { conditionId, outcomes, status }) => {
        outcomes.forEach(({ outcomeId, odds }) => {
            const key = `${conditionId}-${outcomeId}`;
            acc[key] = {
                odds: +odds,
                status,
            };
        });
        return acc;
    }, {});
};
const batchFetchOutcomes = createBatch(getOutcomes);const useSelection = ({ selection, initialOdds, initialStatus }) => {
    const { coreAddress, conditionId, outcomeId } = selection;
    const { appChain, contracts } = useChain();
    const { prematchClient } = useApolloClients();
    const { isSocketReady, subscribeToUpdates, unsubscribeToUpdates } = useSocket();
    const config = useConfig();
    const isLive = coreAddress.toLowerCase() === liveHostAddress.toLowerCase();
    const [odds, setOdds] = useState(initialOdds || 0);
    const [isOddsFetching, setOddsFetching] = useState(!initialOdds);
    const [status, setStatus] = useState(initialStatus || ConditionStatus.Created);
    const [isStatusFetching, setStatusFetching] = useState(!initialStatus);
    const isLocked = status !== ConditionStatus.Created;
    useEffect(() => {
        if (!isLive || !isSocketReady) {
            return;
        }
        subscribeToUpdates([conditionId]);
        return () => {
            unsubscribeToUpdates([conditionId]);
        };
    }, [isSocketReady]);
    useEffect(() => {
        const unsubscribe = oddsWatcher.subscribe(`${conditionId}`, `${outcomeId}`, async (oddsData) => {
            let odds = oddsData?.outcomes?.[String(outcomeId)]?.odds;
            if (!odds) {
                const rawOdds = await readContract(config, {
                    address: contracts.prematchCore.address,
                    abi: contracts.prematchCore.abi,
                    functionName: 'calcOdds',
                    chainId: appChain.id,
                    args: [
                        BigInt(conditionId),
                        BigInt(1),
                        BigInt(outcomeId),
                    ],
                });
                odds = formatUnits(rawOdds, ODDS_DECIMALS);
            }
            else {
                setOddsFetching(false);
            }
            setOdds(+odds);
        });
        return () => {
            unsubscribe();
        };
    }, [config]);
    useEffect(() => {
        const unsubscribe = conditionStatusWatcher.subscribe(`${conditionId}`, (newStatus) => {
            setStatusFetching(false);
            setStatus(newStatus);
        });
        return () => {
            unsubscribe();
        };
    }, []);
    useEffect(() => {
        if (isLive || (initialOdds && initialStatus)) {
            return;
        }
        (async () => {
            const conditionEntityId = `${contracts.prematchCore.address.toLowerCase()}_${conditionId}`;
            const key = `${conditionId}-${outcomeId}`;
            const data = await batchFetchOutcomes([conditionEntityId], prematchClient);
            if (!initialOdds) {
                setOdds(data?.[key]?.odds || 0);
                setOddsFetching(false);
            }
            if (!initialStatus) {
                setStatus(data?.[key]?.status || ConditionStatus.Created);
                setStatusFetching(false);
            }
        })();
    }, [prematchClient]);
    return {
        odds,
        isLocked,
        isOddsFetching,
        isStatusFetching,
    };
};const useBetTokenBalance = () => {
    const { appChain, betToken } = useChain();
    const { address } = useAccount();
    const { isLoading, data, error } = useBalance({
        chainId: appChain.id,
        address,
        token: betToken.address,
    });
    return {
        loading: isLoading,
        rawBalance: data?.value,
        balance: data?.formatted,
        error,
    };
};const useGameStatus = ({ graphStatus, startsAt, isGameExistInLive }) => {
    const startDate = +startsAt * 1000;
    const [isGameStarted, setGameStarted] = useState(Date.now() > startDate);
    const gameStatus = useMemo(() => {
        return getGameStatus({
            graphStatus,
            startsAt,
            isGameInLive: isGameExistInLive,
        });
    }, [graphStatus, isGameStarted, isGameExistInLive]);
    useEffect(() => {
        if (isGameStarted) {
            return;
        }
        const timer = setTimeout(() => {
            setGameStarted(true);
        }, startDate - Date.now());
        return () => {
            clearTimeout(timer);
        };
    }, [startDate]);
    return {
        status: gameStatus,
        isGameStarted,
    };
};const useNativeBalance = () => {
    const { appChain } = useChain();
    const { address } = useAccount();
    const { isLoading, data, error } = useBalance({
        chainId: appChain.id,
        address,
    });
    return {
        loading: isLoading,
        rawBalance: data?.value,
        balance: data?.formatted,
        error,
    };
};const useWaveLevels = ({ waveId } = { waveId: 'active' }) => {
    const { appChain, api } = useChain();
    const queryFn = () => (getWaveLevels({
        chainId: appChain.id,
        waveId,
    }));
    return useQuery({
        queryKey: ['wave/levels', waveId, api],
        queryFn,
        refetchOnWindowFocus: false,
    });
};const useWaveStats = ({ account, waveId = 'active' }) => {
    const { appChain, api } = useChain();
    const queryFn = async () => {
        const data = await getWaveStats({
            account,
            waveId,
            chainId: appChain.id,
        });
        if (!data) {
            return data;
        }
        const { address, levelActivated, ...rest } = data;
        return {
            ...rest,
            isActivated: levelActivated,
        };
    };
    return useQuery({
        queryKey: ['wave/stats', waveId, api, account?.toLowerCase()],
        queryFn,
        refetchOnWindowFocus: false,
        enabled: Boolean(account),
    });
};const useWavePeriods = ({ waveId } = { waveId: 'active' }) => {
    const { appChain, api } = useChain();
    const queryFn = async () => {
        const data = await getWavePeriods({
            waveId,
            chainId: appChain.id,
        });
        if (!data) {
            return data;
        }
        return [...data].reverse().map(({ id, startsAt, endsAt, totalPoints }, index) => {
            const fromTimestamp = new Date(startsAt).getTime();
            const toTimestamp = new Date(endsAt).getTime() - 1000;
            return {
                id,
                startsAt: Math.floor(fromTimestamp / 1000),
                endsAt: Math.floor(toTimestamp / 1000),
                totalPoints,
                isBonusPreCalc: !index,
            };
        });
    };
    return useQuery({
        queryKey: ['wave/periods', waveId, api],
        queryFn,
        refetchOnWindowFocus: false,
    });
};const useWaveLeaderBoard = ({ waveId = 'active', account, startsAt, enabled }) => {
    const { appChain, api } = useChain();
    const queryFn = () => (getWaveLeaderBoard({
        waveId,
        account,
        startsAt,
        chainId: appChain.id,
    }));
    return useQuery({
        queryKey: ['wave/leaderboard', waveId, api, account?.toLowerCase(), startsAt],
        queryFn,
        refetchOnWindowFocus: false,
        enabled,
    });
};const useWaveActivation = ({ account, waveId = 'active' }) => {
    const queryClient = useQueryClient();
    const { appChain, api } = useChain();
    const mutationFn = () => (activateWave({
        account,
        waveId,
        chainId: appChain.id,
    }));
    const { mutate, mutateAsync, isPending } = useMutation({
        mutationFn,
        onSuccess: () => {
            queryClient.invalidateQueries({ queryKey: ['wave/stats', waveId, api, account?.toLowerCase()] });
            queryClient.invalidateQueries({ queryKey: ['wave/leaderboard', waveId, api, account?.toLowerCase()] });
        },
    });
    return {
        activate: mutate,
        activateAsync: mutateAsync,
        isPending,
    };
};const useDebounce = (value, delay) => {
    const [debouncedValue, setDebouncedValue] = useState(value);
    useEffect(() => {
        const timer = setTimeout(() => setDebouncedValue(value), delay || 500);
        return () => {
            clearTimeout(timer);
        };
    }, [value, delay]);
    return debouncedValue;
};const useDeBridgeSupportedChains = ({ enabled } = { enabled: true }) => {
    const queryFn = async () => {
        const chains = await getDeBridgeSupportedChains();
        if (!chains) {
            return chains;
        }
        const chainIds = chains.map(({ originalChainId }) => originalChainId);
        return {
            chains,
            chainIds,
        };
    };
    const { isFetching, data, refetch } = useQuery({
        queryKey: ['/debridge-supported-chains'],
        queryFn,
        enabled,
        refetchOnWindowFocus: false,
    });
    return {
        supportedChains: data?.chains,
        supportedChainIds: data?.chainIds,
        refetch,
        loading: isFetching,
    };
};const useDeBridgeSupportedTokens = ({ chainId, enabled = true }) => {
    const queryFn = async () => {
        const tokens = await getDeBridgeSupportedTokens(chainId);
        if (!tokens) {
            return tokens;
        }
        const supportedTokens = Object.values(tokens);
        return {
            supportedTokens,
            tokenAddresses: supportedTokens.map(({ address }) => address),
        };
    };
    const { isFetching, data, refetch } = useQuery({
        queryKey: ['/debridge-supported-tokens', chainId],
        queryFn,
        enabled,
        refetchOnWindowFocus: false,
    });
    return {
        supportedTokens: data?.supportedTokens,
        supportedTokenAddresses: data?.tokenAddresses,
        refetch,
        loading: isFetching,
    };
};const useDeBridgeBet = (props) => {
    const { fromChainId: _fromChainId, fromTokenAddress: _fromTokenAddress, betAmount: _betAmount, slippage, deadline, referralCode, affiliate, selections, odds, totalOdds, onSuccess, onError, } = props;
    const { prematchClient } = useApolloClients();
    const { addBet } = useBetsCache();
    const publicClient = usePublicClient();
    const config = useConfig();
    const account = useAccount();
    const { appChain, betToken } = useChain();
    const [isBetPending, setBetPending] = useState(false);
    const [isBetProcessing, setBetProcessing] = useState(false);
    const isLiveBet = selections.some(({ coreAddress }) => coreAddress === liveHostAddress);
    const betAmount = useDebounce(_betAmount, 300);
    const fromChainId = useDebounce(_fromChainId, 300);
    const fromTokenAddress = useDebounce(_fromTokenAddress, 300);
    const { supportedChainIds, loading: isDeBridgeSupportedChainsFetching, } = useDeBridgeSupportedChains({
        enabled: !isLiveBet,
    });
    const { supportedTokenAddresses, loading: isDeBridgeSupportedTokensFetching, } = useDeBridgeSupportedTokens({
        chainId: fromChainId,
        enabled: !isLiveBet && !isDeBridgeSupportedChainsFetching && (supportedChainIds || []).includes(fromChainId),
    });
    const queryFn = () => (createDeBridgeBet({
        account: account.address,
        betAmount,
        dstChainId: appChain.id,
        srcChainId: fromChainId,
        srcChainTokenIn: fromTokenAddress,
        selections,
        totalOdds,
        slippage,
        deadline,
        affiliate,
        referralCode,
    }));
    const selectionsKey = selections.map(({ conditionId }) => conditionId).join('-');
    const { isFetching: isCreateTxFetching, data } = useQuery({
        queryKey: ['/debridge-create-tx', fromChainId, fromTokenAddress, account?.address, betAmount, selectionsKey, totalOdds, slippage],
        queryFn,
        enabled: (!isLiveBet
            && !isBetPending
            && !isBetProcessing
            && Boolean(fromChainId)
            && Boolean(fromTokenAddress)
            && Boolean(account)
            && Boolean(+betAmount)
            && Boolean(selections.length)
            && !isDeBridgeSupportedChainsFetching
            && !isDeBridgeSupportedTokensFetching
            && (supportedChainIds || []).includes(appChain.id)
            && (supportedChainIds || []).includes(fromChainId)
            && (supportedTokenAddresses || []).includes(fromTokenAddress)),
        refetchOnWindowFocus: false,
        refetchInterval: 20000,
    });
    const { orderId, estimation, tx: betTxData, fixFee } = data || {};
    const isTxReady = Boolean(betTxData);
    const isNative = estimation?.srcChainTokenIn?.address === zeroAddress;
    const allowanceTx = useReadContract({
        chainId: fromChainId,
        address: estimation?.srcChainTokenIn.address,
        abi: erc20Abi,
        functionName: 'allowance',
        args: [
            account.address,
            betTxData?.to,
        ],
        query: {
            enabled: !isNative && Boolean(account.address) && isTxReady,
            refetchOnWindowFocus: false,
        },
    });
    const isApproveRequired = Boolean(allowanceTx.data !== undefined
        && allowanceTx.data < (BigInt(estimation?.srcChainTokenIn?.amount || 0) * 4n / 3n));
    const approveTx = useWriteContract();
    const betTx = useSendTransaction();
    const approveReceipt = useWaitForTransactionReceipt({
        hash: approveTx.data,
    });
    const approve = async () => {
        try {
            const hash = await approveTx.writeContractAsync({
                address: estimation?.srcChainTokenIn.address,
                abi: erc20Abi,
                chainId: fromChainId,
                functionName: 'approve',
                args: [
                    betTxData?.to,
                    maxUint256,
                ],
            });
            await publicClient.waitForTransactionReceipt({
                hash,
            });
            allowanceTx.refetch();
        }
        catch (err) {
            onError?.(err);
        }
    };
    const placeBet = async () => {
        try {
            setBetPending(true);
            const hash = await betTx.sendTransactionAsync(betTxData);
            setBetPending(false);
            setBetProcessing(true);
            if (publicClient?.chain?.id === fromChainId) {
                await publicClient.waitForTransactionReceipt({
                    hash,
                });
            }
            const txHash = await new Promise((res, rej) => {
                const interval = setInterval(async () => {
                    try {
                        const order = await getDeBridgeOrder(orderId);
                        const { state: orderStatus, externalCallState: betPlacingStatus, fulfilledDstEventMetadata, } = order;
                        const isBetPlaced = betPlacingStatus === DeBridgeExternalCallStatus.Completed;
                        const isOrderFulfilled = isBetPlaced || orderStatus === DeBridgeOrderStatus.Fulfilled || orderStatus === DeBridgeOrderStatus.ClaimedUnlock;
                        if (isOrderFulfilled) {
                            clearInterval(interval);
                            res(fulfilledDstEventMetadata?.transactionHash?.stringValue);
                        }
                        let error = '';
                        if (betPlacingStatus === DeBridgeExternalCallStatus.Cancelled) {
                            error = DeBridgeExternalCallStatus.Cancelled;
                        }
                        if (betPlacingStatus === DeBridgeExternalCallStatus.Failed) {
                            error = DeBridgeExternalCallStatus.Failed;
                        }
                        if (orderStatus === DeBridgeOrderStatus.SentOrderCancel) {
                            error = DeBridgeOrderStatus.SentOrderCancel;
                        }
                        if (orderStatus === DeBridgeOrderStatus.OrderCancelled) {
                            error = DeBridgeOrderStatus.OrderCancelled;
                        }
                        if (error) {
                            clearInterval(interval);
                            rej(error);
                        }
                    }
                    catch { }
                }, 5000);
            });
            let receipt;
            if (txHash) {
                receipt = await getTransactionReceipt(config, {
                    hash: txHash,
                    chainId: appChain.id,
                });
                if (receipt) {
                    const fixedAmount = parseFloat(betAmount).toFixed(betToken.decimals);
                    const rawAmount = parseUnits(fixedAmount, betToken.decimals);
                    addBet({
                        receipt,
                        affiliate,
                        odds,
                        bet: {
                            rawAmount,
                            selections,
                        },
                    });
                }
            }
            else {
                prematchClient.refetchQueries({
                    include: ['Bets'],
                });
            }
            setBetProcessing(false);
            onSuccess?.(receipt);
        }
        catch (err) {
            setBetPending(false);
            setBetProcessing(false);
            onError?.(err);
        }
    };
    const submit = () => {
        if (isApproveRequired) {
            return approve();
        }
        return placeBet();
    };
    return {
        orderId,
        submit,
        estimation,
        fixFee,
        supportedChainIds,
        approveTx: {
            isPending: approveTx.isPending,
            isProcessing: approveReceipt.isLoading,
        },
        betTx: {
            isPending: isBetPending,
            isProcessing: isBetProcessing,
        },
        isAllowanceLoading: allowanceTx.isLoading,
        isApproveRequired,
        isTxReady,
        loading: isCreateTxFetching || isDeBridgeSupportedChainsFetching,
    };
};export{ApolloProvider,AzuroSDKProvider,BaseBetslipContext,BetType,BetslipDisableReason,BetslipProvider,ChainProvider,DetailedBetslipContext,LiveContext,LiveProvider,SocketProvider,SportHub,Watchers,cookieKeys,getApolloClients,localStorageKeys,useActiveConditions,useActiveMarkets,useApolloClients,useBaseBetslip,useBetTokenBalance,useBetsSummary,useBetsSummaryBySelection,useChain,useConditions,useDeBridgeBet,useDeBridgeSupportedChains,useDeBridgeSupportedTokens,useDetailedBetslip,useFreeBets,useGame,useGameStatus,useGames,useLive,useLiveBetFee,useLiveBets,useNativeBalance,useNavigation,useOdds,usePrematchBets,usePrepareBet,useRedeemBet,useResolvedMarkets,useSelection,useSports,useSportsNavigation,useStatuses,useWatchers,useWaveActivation,useWaveLeaderBoard,useWaveLevels,useWavePeriods,useWaveStats};